/**
* Cardinal Payroll System - Spiff/Bonus Utilities
* Contains general helper functions used by the Spiff/Bonus logic.
*/

/**
* Creates an object mapping expected "Spiff/Bonus" sheet column headers to their 1-based column index.
* Uses flexible matching to accommodate variations in header names.
*
* @param {Sheet} sheet - The Spiff/Bonus sheet object.
* @return {Object} An object where keys are standardized header names (e.g., 'customerName')
*                  and values are the corresponding 1-based column indices.
*                  Returns null for keys if the header is not found.
*/
function getSpiffBonusHeaderMap(sheet) {
 if (!sheet) {
   console.error("getSpiffBonusHeaderMap: Sheet object is required.");
   return {}; // Return empty map if no sheet provided
 }
 var headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
 var map = {
   customerName: null,
   jobBusinessUnit: null,
   completionDate: null,
   soldBy: null,
   assignedTechnician: null,
   bonusAmount: null,
   actualBonusAmount: null, // For cases where bonus amount is boolean/true
   itemName: null,
   crossSaleGroup: null
 };

 for (var c = 0; c < headers.length; c++) {
   var h = (headers[c] || "").toString().trim().toLowerCase();
   var columnIndex = c + 1;

   // Match based on common variations
   if (!map.customerName && h.includes("customer") && (h.includes("name") || h.includes("client"))) {
     map.customerName = columnIndex;
   }
   else if (!map.jobBusinessUnit && (h.includes("business") && h.includes("unit") || h.includes("bu") || h === "dept")) {
     map.jobBusinessUnit = columnIndex;
   }
   else if (!map.completionDate && ((h.includes("completion") || h.includes("complete")) && h.includes("date"))) {
     map.completionDate = columnIndex;
   }
   else if (!map.completionDate && (h === "date" || h === "job date")) { // Allow fallback generic date
     map.completionDate = columnIndex;
   }
   else if (!map.soldBy && (h.includes("sold") && h.includes("by"))) {
     map.soldBy = columnIndex;
   }
   else if (!map.assignedTechnician && (h === "tech" || h === "technician" || h === "assigned tech")) {
     map.assignedTechnician = columnIndex;
   }
   else if (!map.bonusAmount && (h.includes("bonus") || h.includes("spiff") || h.includes("commission") || h.includes("amt") || h.includes("amount") || h.includes("$"))) {
     // Prioritize finding the *main* bonus amount column first
     if (h === "bonus" || h === "bonus amount" || h === "spiff" || h === "spiff amount") { // More specific names take precedence
         map.bonusAmount = columnIndex;
     }
   }
   else if (!map.itemName && ((h.includes("item") && h.includes("name")) || h === "task" || h === "service" || h === "description")) {
     map.itemName = columnIndex;
   }
 }

 // --- Refinements and Fallbacks ---

 // If the primary bonus amount wasn't found with specific terms, try broader terms again
 if (!map.bonusAmount) {
    for (var c2 = 0; c2 < headers.length; c2++) {
        var h2 = (headers[c2] || "").toString().trim().toLowerCase();
        var colIdx2 = c2 + 1;
        if (h2.includes("bonus") || h2.includes("spiff") || h2.includes("commission") || h2.includes("amt") || h2.includes("amount") || h2.includes("$")) {
            map.bonusAmount = colIdx2;
            console.log(`Fallback found bonusAmount: '${headers[c2]}' in column ${colIdx2}`);
            break; // Take the first match found this way
        }
    }
 }

 // Look for 'Actual Bonus Amount' or similar, often in the column *after* the main bonus column
 if (map.bonusAmount) {
   var nextIndex = map.bonusAmount; // This is 1-based index + 1 = next column
   if (nextIndex < headers.length) { // Check if next column exists
     var nextHeader = (headers[nextIndex] || "").toString().trim().toLowerCase();
     // Check if the *next* column seems like an amount column (useful if main one is boolean)
     if (nextHeader.includes("actual") || nextHeader.includes("$") || nextHeader.includes("amount") || nextHeader.includes("value")) {
       map.actualBonusAmount = nextIndex + 1; // map.bonusAmount is 1-based, headers is 0-based, so +1 gets 1-based next col index
       console.log(`Found actualBonusAmount: '${headers[nextIndex]}' in column ${map.actualBonusAmount}`);
     }
   }
 }

 // If 'Sold By' wasn't found, specifically check for "Sold By Technician"
 if (!map.soldBy) {
   for (var c3 = 0; c3 < headers.length; c3++) {
     var hh = (headers[c3] || "").toString().trim(); // Case-sensitive check might be needed?
     if (hh === "Sold By Technician") {
       map.soldBy = c3 + 1;
       console.log(`Found Sold By column: '${hh}' in column ${map.soldBy}`);
       break;
     }
   }
 }

 // Add logic to find 'Cross Sale Group'
 if (!map.crossSaleGroup) {
   for (var c4 = 0; c4 < headers.length; c4++) {
     var h4 = (headers[c4] || "").toString().trim().toLowerCase();
     var colIdx4 = c4 + 1;
     if (h4.includes("cross") && h4.includes("sale") && h4.includes("group")) {
       map.crossSaleGroup = colIdx4;
       console.log(`Found crossSaleGroup: '${headers[c4]}' in column ${colIdx4}`);
       break;
     }
   }
 }
 // If still not found, try a simpler match (e.g., check column J explicitly if headers are consistent)
 if (!map.crossSaleGroup && headers.length >= 10) { // Check if Column J exists
    var headerJ = (headers[9] || "").toString().trim().toLowerCase(); // Index 9 is Column J
    if (headerJ.includes("cross") && headerJ.includes("sale")) {
        map.crossSaleGroup = 10; // Default to Column J (index 10)
        console.log(`Assumed crossSaleGroup: '${headers[9]}' in column 10 (J)`);
    }
 }

 // Last resort: If specific key headers are *still* missing, assign defaults or log warnings
 // Example: Default 'Sold By' to column F (index 6) if absolutely necessary
 if (!map.soldBy) {
   console.warn("Could not find 'Sold By' column header. Defaulting to Column F (index 6). This may be incorrect.");
   map.soldBy = 6;
 }

 // Log any headers that were not successfully mapped
 for (var key in map) {
    if (map[key] === null) {
        console.warn(`Header key '${key}' could not be mapped to a column in the Spiff/Bonus sheet.`);
    }
 }

 console.log("Spiff/Bonus Header Map: ", map);
 return map;
}


/**
* Finds the first row within a specified range that exactly matches the given text in a specific column.
* Search is case-insensitive and trims whitespace.
*
* @param {Sheet} sheet - The sheet object to search in.
* @param {string} textToFind - The text to search for.
* @param {number} column_one_indexed - The 1-based column index to search within.
* @param {number} [startRow=1] - Optional 1-based start row for the search.
* @param {number} [endRow] - Optional 1-based end row for the search (defaults to sheet's last row).
* @param {boolean} [allowPartialMatch=false] - Whether to allow partial matches.
* @return {number} The 1-based row number where the text was found, or -1 if not found.
*/
function findRowWithText(sheet, textToFind, column_one_indexed, startRow, endRow, allowPartialMatch) {
 if (!sheet || !textToFind || !column_one_indexed || column_one_indexed < 1) {
   console.error("findRowWithText: Invalid parameters. Requires sheet, textToFind, and valid column_one_indexed.");
   return -1;
 }
 var searchCol = column_one_indexed;
 var begin = startRow || 1;
 var maxRow = endRow || sheet.getLastRow();
 var isPartialMatch = allowPartialMatch || false;

 if (begin > maxRow) {
     console.log(`findRowWithText: Start row (${begin}) is after end row (${maxRow}). No search performed.`);
     return -1;
 }

 // Optimize by getting values in a batch if searching multiple rows
 var numRowsToSearch = maxRow - begin + 1;
 if (numRowsToSearch <= 0) return -1;

 try {
   var range = sheet.getRange(begin, searchCol, numRowsToSearch, 1);
   var values = range.getValues();
   var searchTextLower = textToFind.trim().toLowerCase();

   for (var i = 0; i < values.length; i++) {
     var cellValue = values[i][0];
     if (cellValue && typeof cellValue === 'string') {
       var cellLower = cellValue.trim().toLowerCase();
       
       if ((isPartialMatch && cellLower.includes(searchTextLower)) || 
           (!isPartialMatch && cellLower === searchTextLower)) {
         return begin + i; // Return the 1-based row index
       }
     }
   }
 } catch (e) {
     console.error(`findRowWithText: Error getting range or values (Row ${begin}, Col ${searchCol}, NumRows ${numRowsToSearch}): ${e.message}`);
     // Fallback to row-by-row if batch fails (though unlikely for single column read)
     for (var r = begin; r <= maxRow; r++) {
         try {
             var val = sheet.getRange(r, searchCol).getValue();
             if (val && typeof val === 'string') {
               var valLower = val.trim().toLowerCase();
               if ((isPartialMatch && valLower.includes(searchTextLower)) || 
                   (!isPartialMatch && valLower === searchTextLower)) {
                 return r;
               }
             }
         } catch (singleRowError) {
             console.error(`findRowWithText: Error reading single cell (Row ${r}, Col ${searchCol}): ${singleRowError.message}`);
             // Potentially break or continue depending on desired error handling
         }
     }
 }

 return -1; // Not found
}


/**
* Attempts to parse a value (string, number, or Date object) into a valid JavaScript Date object.
* Handles common date formats like MM/DD/YYYY and ISO strings.
*
* @param {*} input - The value to parse (can be a string, number representing milliseconds, or a Date object).
* @return {Date|null} A valid Date object if parsing is successful, otherwise null.
*/
function tryParseDate(input) {
 if (!input) return null;

 // If it's already a valid Date object
 if (input instanceof Date && !isNaN(input.getTime())) {
   return input;
 }

 try {
   // Try direct parsing (handles ISO strings, potentially other formats)
   var d = new Date(input);
   if (!isNaN(d.getTime())) return d;

   // If it's a string, try common spreadsheet format (e.g., M/D/YYYY)
   if (typeof input === 'string') {
     var parts = input.split(/[/\-]/); // Split by slash, backslash, or hyphen
     if (parts.length === 3) {
       // Attempt MM/DD/YYYY or M/D/YYYY
       var year = parseInt(parts[2], 10);
       var month = parseInt(parts[0], 10);
       var day = parseInt(parts[1], 10);

       // Basic sanity check for year (e.g., 4 digits)
       if (year > 1000 && year < 3000 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
         // Note: JavaScript Date constructor month is 0-indexed
         d = new Date(year, month - 1, day);
         // Double-check that the constructed date matches the input parts (handles invalid dates like 2/30)
         if (!isNaN(d.getTime()) && d.getFullYear() === year && (d.getMonth() + 1) === month && d.getDate() === day) {
            return d;
         }
       }
     }
   }

   // Could add more specific parsing logic here if needed (e.g., for DD-MMM-YYYY)

 } catch(e) {
   // Ignore parsing errors, will return null below
   console.log(`tryParseDate: Error parsing input '${input}': ${e.message}`);
 }

 console.log(`tryParseDate: Could not parse '${input}' into a valid Date object.`);
 return null;
}


/**
* Returns a standard mapping object for columns in the "Hourly + Spiff Pay" sheet.
* This helps centralize the column definitions used across different functions.
*
* @return {Object} An object with keys for common fields (nameColumn, actionColumn, etc.)
*                  and values representing their 1-based column index and the data start row.
*/
function getRatesSheetMapping() {
 // These indices correspond to the columns in the 'Hourly + Spiff Pay' sheet
 return {
   nameColumn: 1,       // Column A: Technician Name
   positionColumn: 2,   // Column B: Position
   rateColumn: 4,       // Column D: Base Rate (example, might not be used by Spiff directly)
   actionColumn: 7,     // Column G: Action Dropdown
   dataStartRow: 3      // Row number where the actual technician data begins (below headers)
 };
} 