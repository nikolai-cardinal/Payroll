/**
 * Functions for handling sheet operations related to lead data.
 */

/**
 * Finds the Lead Set sheet in the spreadsheet.
 * 
 * @param {SpreadsheetApp.Spreadsheet} ss - The spreadsheet to search in.
 * @return {SpreadsheetApp.Sheet|null} The Lead Set sheet or null if not found.
 */
function findLeadSetSheet(ss) {
  try {
    return ss.getSheetByName('Lead Set');
  } catch (error) {
    Logger.log('Error finding Lead Set sheet: ' + error.message);
    return null;
  }
}

/**
 * Gets lead data for a specific technician from the Lead Set sheet.
 * 
 * @param {SpreadsheetApp.Sheet} leadSetSheet - The Lead Set sheet.
 * @param {String} technicianName - The name of the technician.
 * @return {Array} Array of lead data objects.
 */
function getLeadDataForTechnician(leadSetSheet, technicianName) {
  console.log(`Fetching lead data for technician: ${technicianName}`);
  const data = leadSetSheet.getDataRange().getValues();
  
  if (data.length === 0) {
    console.error("Lead Set sheet is empty");
    return [];
  }
  
  const headers = data[0];
  
  // Find column indices by header name instead of hardcoding positions
  let techIndex = -1;
  let customerIndex = -1;
  let unitIndex = -1;
  let dateIndex = -1;
  let revenueIndex = -1;
  
  // Search for column headers
  for (let i = 0; i < headers.length; i++) {
    const header = headers[i] ? headers[i].toString().trim().toLowerCase() : '';
    
    if (header.includes('lead generated') || header.includes('generated by')) {
      techIndex = i;
    } else if (header.includes('customer')) {
      customerIndex = i;
    } else if (header.includes('business unit')) {
      unitIndex = i;
    } else if (header.includes('completion date')) {
      dateIndex = i;
    } else if (header.includes('revenue') || header.includes('total')) {
      revenueIndex = i;
    }
  }
  
  // If we can't find the necessary columns, default to expected positions
  if (techIndex === -1) techIndex = 6;  // Column G - Lead Generated By
  if (customerIndex === -1) customerIndex = 2;  // Column C - Customer Name
  if (unitIndex === -1) unitIndex = 3;  // Column D - Business Unit
  if (dateIndex === -1) dateIndex = 1;  // Column B - Completion Date
  if (revenueIndex === -1) revenueIndex = 4;  // Column E - Job Total Revenue
  
  console.log(`Column indices found: Tech=${techIndex}, Customer=${customerIndex}, Unit=${unitIndex}, CompDate=${dateIndex}, Rev=${revenueIndex}`);
  
  // Debug headers row
  console.log(`Headers row: ${headers.join(' | ')}`);
  
  // Filter data for the specified technician in the Lead Generated By column
  const technicianData = [];
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    
    // Debug first few rows
    if (i < 5) {
      console.log(`Row ${i} lead generated by: "${row[techIndex]}", searching for: "${technicianName}"`);
    }
    
    if (row[techIndex] === technicianName) {
      technicianData.push({
        customer: row[customerIndex],
        businessUnit: row[unitIndex],
        completionDate: row[dateIndex],
        revenue: row[revenueIndex],
        notes: '',
      });
    }
  }
  
  console.log(`Found ${technicianData.length} leads for ${technicianName}`);
  return technicianData;
}

/**
 * Writes lead set data to a technician's sheet.
 * Main entry point for writing lead data.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Array} leadData - Array of lead data objects.
 * @return {Boolean} True if successful, false otherwise.
 */
function writeLeadSetDataToSheet(techSheet, leadData) {
  if (!leadData || leadData.length === 0) {
    return true; // Nothing to do, considered successful
  }
  
  // Validate technician sheet structure
  if (!validateSheetStructure(techSheet)) {
    return false;
  }
  
  try {
    // Process data and update the sheet in batches
    const calculatedData = calculateLeadAmounts(leadData);
    clearAndWriteLeadEntries(techSheet, calculatedData.formattedEntries);
    updateLeadSummaryInfo(techSheet, calculatedData.count, calculatedData.total);
    return true;
  } catch (error) {
    Logger.log(`Error writing lead set data: ${error.message}`);
    return false;
  }
}

/**
 * Validates the technician sheet structure for lead operations.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician sheet to validate.
 * @return {Boolean} True if valid, false otherwise.
 */
function validateSheetStructure(techSheet) {
  if (typeof validateTechnicianSheetForLeadSet === 'function' && 
      !validateTechnicianSheetForLeadSet(techSheet)) {
    Logger.log(`Technician sheet ${techSheet.getName()} has invalid structure for lead set operations`);
    return false;
  }
  return true;
}

/**
 * Calculates commission amounts for lead data entries.
 * 
 * @param {Array} leadData - Raw lead data.
 * @return {Object} Processed data with formatted entries, count and total.
 */
function calculateLeadAmounts(leadData) {
  let total = 0;
  const formattedEntries = [];
  
  for (const lead of leadData) {
    // Calculate commission amount
    let amount = 0;
    if (typeof lead.amount === 'number') {
      amount = lead.amount;
    } else if (typeof lead.revenue === 'number' && typeof calculateLeadCommission === 'function') {
      amount = calculateLeadCommission(lead.revenue).amount;
    } else if (typeof lead.revenue === 'number') {
      amount = lead.revenue * 0.05; // 5% fallback
    }
    
    total += amount;
    formattedEntries.push({
      customer: lead.customer || lead.customerName,
      businessUnit: lead.businessUnit || lead.unit,
      completionDate: lead.completionDate || lead.date,
      amount: amount,
      notes: lead.notes || '',
      marker: 'L-E-A-D'
    });
  }
  
  return {
    formattedEntries: formattedEntries,
    count: formattedEntries.length,
    total: total
  };
}

/**
 * Clears existing lead entries and writes new ones in a batch operation.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician sheet.
 * @param {Array} entries - Formatted lead entries to write.
 */
function clearAndWriteLeadEntries(techSheet, entries) {
  // Clear existing entries
  const existingRows = findExistingLeadSetRows(techSheet);
  clearExistingLeadEntries(techSheet, existingRows);
  
  // Prepare data for batch write
  const startRow = findFirstEmptyRow(techSheet);
  const values = entries.map(entry => [
    entry.customer,
    entry.businessUnit,
    entry.completionDate,
    entry.amount,
    entry.notes,
    entry.marker
  ]);
  
  // Write all data at once if we have any
  if (values.length > 0) {
    // Batch write all entries
    techSheet.getRange(startRow, 5, values.length, 6).setValues(values);
    
    // Format cells in batch
    techSheet.getRange(startRow, 8, values.length, 1).setNumberFormat('$#,##0.00');
    techSheet.getRange(startRow, 7, values.length, 1).setNumberFormat('mm/dd/yyyy');
  }
}

/**
 * Updates the lead summary information in a batch operation.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician sheet.
 * @param {Number} count - Number of leads.
 * @param {Number} total - Total commission amount.
 */
function updateLeadSummaryInfo(techSheet, count, total) {
  // Update summary info in batch
  const updateRanges = [
    techSheet.getRange(14, 2), // Lead count
    techSheet.getRange(13, 3)  // Commission total
  ];
  
  const updateValues = [
    [count],
    [total]
  ];
  
  // Update count and total
  for (let i = 0; i < updateRanges.length; i++) {
    updateRanges[i].setValue(updateValues[i][0]);
  }
  
  // Format commission total
  updateRanges[1].setNumberFormat('$#,##0.00');
}

/**
 * Finds rows containing "L-E-A-D" in column J.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @return {Array} Array of row indexes (1-based) containing lead entries.
 */
function findExistingLeadSetRows(techSheet) {
  console.log(`Debug: Finding existing lead rows in ${techSheet.getName()}`);
  
  const data = techSheet.getDataRange().getValues();
  const leadRows = [];
  
  // Look for "L-E-A-D" in column J (index 9)
  for (let i = 0; i < data.length; i++) {
    const cellValue = data[i][9]; // Column J (index 9)
    
    // Only log some rows to avoid excessive logging
    if (i < 20 || (cellValue && cellValue.toString().includes('L-E-A-D'))) {
      console.log(`Debug: Row ${i+1}, Column J value: "${cellValue}", type: ${typeof cellValue}`);
    }
    
    // Improved check for L-E-A-D markers
    if (cellValue !== null && cellValue !== undefined) {
      const strValue = cellValue.toString().trim();
      
      // Check both exact match and substring match for maximum robustness
      if (strValue === 'L-E-A-D' || strValue.includes('L-E-A-D')) {
        leadRows.push(i + 1); // +1 for 1-based row index
        console.log(`Debug: Found L-E-A-D marker at row ${i+1}`);
      }
    }
  }
  
  console.log(`Debug: Found total of ${leadRows.length} rows with L-E-A-D markers: ${leadRows.join(', ')}`);
  return leadRows;
}

/**
 * Clears existing lead entries from a technician's sheet.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Array} rowIndexes - Array of row indexes to clear, if not provided will find them.
 */
function clearExistingLeadEntries(techSheet, rowIndexes) {
  // If row indexes not provided, find them
  if (!rowIndexes) {
    rowIndexes = findExistingLeadSetRows(techSheet);
  }
  
  // Clear each row (columns E through J)
  rowIndexes.forEach(rowIndex => {
    techSheet.getRange(rowIndex, 5, 1, 6).clearContent();
  });
}

/**
 * Updates the lead summary information in rows 13-14 of a technician's sheet.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Number} count - The number of leads.
 * @param {Number} total - The total lead payment amount.
 */
function updateTopSummaryLeadSet(techSheet, count, total) {
  // Update row 14, column B with lead count
  techSheet.getRange(14, 2).setValue(count);
  
  // Update row 13, column C with commission information
  const totalCell = techSheet.getRange(13, 3);
  totalCell.setValue(total);
  formatLeadSetCells(totalCell);
}

/**
 * Writes new lead entries to the technician's sheet.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Array} entries - Array of lead data objects.
 */
function writeNewLeadEntries(techSheet, entries) {
  if (!entries || entries.length === 0) {
    console.log(`Debug: No entries to write to ${techSheet.getName()}`);
    return;
  }
  
  console.log(`Debug: Writing ${entries.length} new lead entries to ${techSheet.getName()}`);
  
  // Find where to start writing data (first empty row in the commission section)
  const startRow = findFirstEmptyRow(techSheet);
  console.log(`Debug: Starting to write at row ${startRow}`);
  
  // Prepare data for batch update
  const values = [];
  
  for (const entry of entries) {
    // Format completion date if it's a Date object
    let formattedDate = entry.completionDate || entry.date || '';
    if (formattedDate instanceof Date) {
      formattedDate = Utilities.formatDate(formattedDate, Session.getScriptTimeZone(), 'MM/dd/yyyy');
    }
    
    // Ensure we always write 'L-E-A-D' in column J for easy identification
    const marker = 'L-E-A-D';
    
    values.push([
      entry.customer || entry.customerName || '', // Column E: Customer name
      entry.businessUnit || entry.unit || '',     // Column F: Business unit
      formattedDate,                              // Column G: Completion date
      entry.amount || entry.payment || 0,         // Column H: Commission amount
      entry.notes || '',                          // Column I: Notes
      marker                                      // Column J: Lead identifier
    ]);
    
    console.log(`Debug: Prepared entry for ${entry.customer || entry.customerName || 'Unknown'} with marker "${marker}"`);
  }
  
  // Write all data at once
  techSheet.getRange(startRow, 5, values.length, 6).setValues(values);
  console.log(`Debug: Wrote ${values.length} entries starting at row ${startRow}, columns E-J (5-10)`);
  
  // Format all commission amounts at once
  techSheet.getRange(startRow, 8, values.length, 1).setNumberFormat('$#,##0.00');
  
  // Format all dates at once
  techSheet.getRange(startRow, 7, values.length, 1).setNumberFormat('mm/dd/yyyy');
}

/**
 * Applies proper formatting to lead set cells.
 * 
 * @param {SpreadsheetApp.Range} range - The range to format.
 */
function formatLeadSetCells(range) {
  if (!range) return;
  
  // Determine what to format based on column
  const column = range.getColumn();
  
  if (column === 8 || column === 3) {
    // Commission amount formatting (column H or C)
    range.setNumberFormat('$#,##0.00');
  } else if (column === 7) {
    // Date formatting (column G)
    range.setNumberFormat('mm/dd/yyyy');
  }
}

/**
 * Finds the first empty row in the commission section of a technician's sheet.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @return {Number} The row number of the first empty row.
 */
function findFirstEmptyRow(techSheet) {
  const data = techSheet.getDataRange().getValues();
  
  // Start from row 2 (index 1) right after the header row
  // and look for the first empty row in columns E-J (indexes 4-9)
  for (let i = 1; i < data.length; i++) {
    // Check if this row is empty in columns E-J
    const rowEmpty = !data[i][4] && !data[i][5] && !data[i][6] && 
                     !data[i][7] && !data[i][8] && !data[i][9];
    
    if (rowEmpty) {
      return i + 1; // +1 because array is 0-indexed, but sheets are 1-indexed
    }
  }
  
  // If no empty row found, return the next row after the last data row
  return data.length + 1;
}

/**
 * Processes all lead set data for all technicians.
 * This function is called from the "All Lead Set" menu item.
 */
function processAllLeadSets() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ui = SpreadsheetApp.getUi();
    
    // Find the Lead Set sheet
    const leadSetSheet = findLeadSetSheet(ss);
    if (!leadSetSheet) {
      ui.alert('Error: Could not find "Lead Set" sheet.');
      return;
    }
    
    // Get all technician names from the Hourly + Spiff Pay sheet
    const ratesSheet = ss.getSheetByName('Hourly + Spiff Pay');
    if (!ratesSheet) {
      ui.alert('Error: Could not find "Hourly + Spiff Pay" sheet.');
      return;
    }
    
    // Get rates sheet mapping
    const ratesMapping = getRatesSheetMapping();
    const dataRange = ratesSheet.getRange(
      ratesMapping.dataStartRow, 
      ratesMapping.nameColumn, 
      ratesSheet.getLastRow() - ratesMapping.dataStartRow + 1, 
      1
    );
    
    const technicianNames = dataRange.getValues().flat().filter(name => 
      name && typeof name === 'string' && name.trim() !== ''
    );
    
    if (technicianNames.length === 0) {
      ui.alert('No technicians found in Hourly + Spiff Pay sheet.');
      return;
    }
    
    let processedCount = 0;
    let skippedCount = 0;
    const processedTechs = [];
    const skippedTechs = [];
    
    // Process each technician
    for (const techName of technicianNames) {
      const techSheet = ss.getSheetByName(techName);
      
      if (!techSheet) {
        skippedTechs.push(techName + ' (Sheet not found)');
        skippedCount++;
        continue;
      }
      
      try {
        // Get lead data for this technician
        const leadData = getLeadDataForTechnician(leadSetSheet, techName);
        
        // Write the lead data to the technician's sheet
        writeLeadSetDataToSheet(techSheet, leadData);
        
        processedTechs.push(techName);
        processedCount++;
      } catch (err) {
        skippedTechs.push(techName + ': ' + err.message);
        skippedCount++;
        Logger.log("Error processing " + techName + ": " + err.message);
      }
    }
    
    // Display summary message
    const summaryMessage = `LEAD SET PROCESSING COMPLETE

SUMMARY:
• Processed: ${processedCount} technicians
${processedCount > 0 ? '• ' + processedTechs.join(', ') : ''}
${skippedCount > 0 ? '\nSkipped: ' + skippedCount + ' technicians\n• ' + skippedTechs.join('\n• ') : ''}`;
    
    ui.alert(summaryMessage);
    
  } catch (e) {
    Logger.log("Error in processAllLeadSets: " + e.message);
    SpreadsheetApp.getUi().alert("Error processing lead sets: " + e.message);
  }
}

/**
 * Gets the field mappings for the Hourly + Spiff Pay sheet
 * @return {Object} An object containing column indexes for important fields
 */
function getRatesSheetMapping() {
  return {
    nameColumn: 1,       // Column A - Technician name
    positionColumn: 2,   // Column B - Position
    rateColumn: 4,       // Column D - Base Rate
    actionColumn: 7,     // Column G - Action column
    dataStartRow: 3      // Data starts at row 3
  };
}

/**
 * Finds the row where the Install Customer Data section starts.
 * @param {SpreadsheetApp.Sheet} sheet - The sheet to search in.
 * @return {number} The row number (1-based) or -1 if not found.
 */
function findInstallCustomerDataSection(sheet) {
  if (!sheet) return -1;
  console.log(`Debug: Searching for Install section in sheet: ${sheet.getName()}`);
  
  var data = sheet.getRange("A1:A50").getValues(); // Search first 50 rows
  
  // First attempt: Exact match
  for (var i = 0; i < data.length; i++) {
    var value = data[i][0];
    if (value && typeof value === "string") {
      var trimmedValue = value.trim();
      console.log(`Debug: Row ${i+1}, Column A value: "${trimmedValue}"`);
      
      if (trimmedValue === "Install [Customer Data]" || 
          trimmedValue === "Install Customer Data" || 
          trimmedValue === "Install & Sales") { 
        console.log(`Debug: Found install section: '${trimmedValue}' at row ${i+1}`);
        return i + 1; 
      }
    }
  }
  
  // Fallback search (case-insensitive, partial, within first 50 rows)
  console.log(`Debug: No exact Install section match found, trying partial matches`);
  for (var i = 0; i < data.length; i++) {
     var value = data[i][0];
     if (value && typeof value === "string") {
       var lowerValue = value.toLowerCase().trim();
       if (lowerValue.includes("install") && 
           (lowerValue.includes("customer") || 
            lowerValue.includes("data") || 
            lowerValue.includes("sales") || 
            lowerValue.includes("&"))) {
         console.log(`Debug: Found install section using partial match: '${value}' at row ${i+1}`);
         return i + 1;
       }
     }
  }
  
  console.log(`Debug: No Install section header found in sheet: ${sheet.getName()}`);
  return -1;
}

/**
 * Finds the row where the next section after Install starts.
 * @param {SpreadsheetApp.Sheet} sheet - The sheet to search in.
 * @param {number} installSectionRow - The row where the Install section starts.
 * @return {number} The row number (1-based) or -1 if not found.
 */
function findNextSectionAfterInstall(sheet, installSectionRow) {
  if (!sheet || installSectionRow <= 0) return -1;
  console.log(`Debug: Searching for next section after Install section (row ${installSectionRow})`);
  
  var startSearchRow = installSectionRow + 3; // Start looking below header/first data
  var maxSearchRow = Math.min(sheet.getLastRow() + 1, installSectionRow + 60); // Search up to 60 rows after install
  
  console.log(`Debug: Will search from row ${startSearchRow} to row ${maxSearchRow-1}`);
  
  if (startSearchRow >= maxSearchRow) {
    console.log(`Debug: Search range is empty or invalid`);
    return -1;
  }

  var searchValues = sheet.getRange(startSearchRow, 1, maxSearchRow - startSearchRow, 1).getValues();
  
  for (var i = 0; i < searchValues.length; i++) {
    var rowValue = searchValues[i][0];
    var actualRow = startSearchRow + i;
    
    if (rowValue && typeof rowValue === "string") {
      var trimmedValue = rowValue.trim();
      var lowerValue = trimmedValue.toLowerCase();
      
      console.log(`Debug: Row ${actualRow}, Column A value: "${trimmedValue}"`);
      
      // Look for non-empty cells that don't seem like data continuation or total rows
      if (trimmedValue.length > 0 && 
          !lowerValue.includes("install") && 
          !lowerValue.includes("total")) {
          
        // Simple check: If it contains common section words or ends with 'Data]'?
        if (lowerValue.includes("data") || 
            lowerValue.includes("sales") || 
            lowerValue.includes("spiff") || 
            lowerValue.includes("bonus") || 
            lowerValue.includes("lead") || 
            lowerValue.includes("customer") || 
            trimmedValue.endsWith("Data]")) {
            
          console.log(`Debug: Found next section header '${trimmedValue}' at row ${actualRow}`);
          return actualRow;
        }
      }
    }
  }
  
  console.log(`Debug: No next section found after Install section in sheet: ${sheet.getName()}`);
  return -1;
}

/**
 * Clears the data rows in the Install section where Type column (J) contains 'L-E-A-D'.
 * Only clears columns E-J (5-10), preserving columns A-D.
 *
 * @param {SpreadsheetApp.Sheet} sheet - The technician sheet to clear.
 * @return {number} The number of rows cleared
 */
function clearLeadDataInInstallSection(sheet) {
  if (!sheet) return 0;
  try {
    console.log(`Starting clearLeadDataInInstallSection for sheet ${sheet.getName()}`);
    
    // Get all values in column J
    var columnJ = sheet.getRange(1, 10, sheet.getLastRow(), 1).getValues();
    console.log(`Scanning ${columnJ.length} rows in column J for L-E-A-D markers`);
    
    // Find rows with L-E-A-D in column J
    var rowsToClean = [];
    for (var i = 0; i < columnJ.length; i++) {
      var cellValue = columnJ[i][0];
      if (cellValue && cellValue.toString().includes('L-E-A-D')) {
        rowsToClean.push(i + 1); // Add 1 for 1-based row index
      }
    }
    
    console.log(`Found ${rowsToClean.length} rows with L-E-A-D markers to clear`);
    
    // Clear those rows (columns E-J)
    for (var i = 0; i < rowsToClean.length; i++) {
      var row = rowsToClean[i];
      sheet.getRange(row, 5, 1, 6).clearContent(); // Clear columns E-J (5-10)
    }
    
    console.log(`Cleared ${rowsToClean.length} rows with L-E-A-D markers`);
    return rowsToClean.length;
  } catch (e) {
    console.error(`Error clearing lead data: ${e.message}`);
    return 0;
  }
}

/**
 * Smart data writing function that reuses existing rows when possible.
 * Updates technician sheet with lead data in a efficient way that minimizes disruption.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Array} leadEntries - The lead entries to write.
 * @param {Number} totalAmount - The total lead commission amount.
 */
function smartWriteLeadDataToSheet(techSheet, leadEntries, totalAmount) {
  if (!techSheet) {
    Logger.log("Cannot write lead data: invalid technician sheet");
    return;
  }
  
  // 1. Update top summary
  updateTopSummaryLeadSet(techSheet, leadEntries.length, totalAmount);
  
  // 2. Find existing LEAD rows
  var existingLeadRows = findExistingLeadSetRows(techSheet);
  
  // 3. Prepare data for writing
  var dataToWrite = [];
  
  for (var i = 0; i < leadEntries.length; i++) {
    var entry = leadEntries[i];
    var dateStr = "";
    
    // Format date if needed
    if (entry.completionDate) {
      if (entry.completionDate instanceof Date) {
        dateStr = Utilities.formatDate(entry.completionDate, 
                                     Session.getScriptTimeZone(), 
                                     "MM/dd/yyyy");
      } else {
        dateStr = entry.completionDate.toString();
      }
    }
    
    dataToWrite.push([
      entry.customer || entry.customerName || "",  // Column E: Customer name
      entry.businessUnit || entry.unit || "",      // Column F: Business unit
      dateStr,                                     // Column G: Completion date
      entry.amount || entry.payment || 0,          // Column H: Commission amount
      entry.notes || "",                           // Column I: Notes
      "L-E-A-D"                                    // Column J: Lead identifier
    ]);
  }
  
  // 4. Write data to the sheet
  if (dataToWrite.length === 0) {
    Logger.log("No lead data to write");
    return;
  }
  
  // If we have existing lead rows, update them
  if (existingLeadRows.length > 0) {
    Logger.log("Found " + existingLeadRows.length + " existing LEAD rows to update");
    
    // The number of rows we need to update
    var rowsToUpdate = Math.min(existingLeadRows.length, dataToWrite.length);
    
    // Update existing rows first
    for (var i = 0; i < rowsToUpdate; i++) {
      var targetRow = existingLeadRows[i];
      var targetRange = techSheet.getRange(targetRow, 5, 1, 6); // Columns E-J (5-10)
      targetRange.setValues([dataToWrite[i]]);
    }
    
    // If we have more entries than existing lead rows, find empty rows for the rest
    if (dataToWrite.length > existingLeadRows.length) {
      var remainingEntries = dataToWrite.slice(existingLeadRows.length);
      writeRemainingLeadEntries(techSheet, remainingEntries);
    }
    
    // If we have fewer entries than existing lead rows, clear the excess rows
    if (existingLeadRows.length > dataToWrite.length) {
      Logger.log("Clearing " + (existingLeadRows.length - dataToWrite.length) + " excess L-E-A-D rows");
      for (var j = dataToWrite.length; j < existingLeadRows.length; j++) {
        var excessRow = existingLeadRows[j];
        techSheet.getRange(excessRow, 5, 1, 6).clearContent();
      }
    }
  } else {
    // No existing lead rows, write all entries to empty rows
    writeRemainingLeadEntries(techSheet, dataToWrite);
  }
  
  Logger.log("Smart update finished for: " + techSheet.getName());
}

/**
 * Writes lead entries to empty rows in the sheet.
 * Used as part of the smartWriteLeadDataToSheet function.
 * 
 * @param {SpreadsheetApp.Sheet} sheet - The technician sheet.
 * @param {Array} entries - The formatted lead entries to write.
 */
function writeRemainingLeadEntries(sheet, entries) {
  if (!entries || entries.length === 0) return;
  
  // Find the header row with "Customer Name" in column E
  var headerRow = findCustomerNameHeaderRow(sheet);
  if (headerRow <= 0) {
    Logger.log("Could not find 'Customer Name' header in column E in " + sheet.getName());
    return;
  }
  
  // Start looking at the row after the header
  var firstDataRow = headerRow + 1;
  var lastRow = sheet.getLastRow();
  
  // Find first empty row in columns E-J
  var startRow = -1;
  var rowsToSearch = Math.min(50, lastRow - firstDataRow + 1); // Cap at 50 rows
  
  if (rowsToSearch > 0) {
    var rowData = sheet.getRange(firstDataRow, 5, rowsToSearch, 6).getValues(); // Columns E-J (5-10)
    
    for (var i = 0; i < rowData.length; i++) {
      var isEmpty = true;
      for (var j = 0; j < rowData[i].length; j++) {
        if (rowData[i][j] !== "") {
          isEmpty = false;
          break;
        }
      }
      
      if (isEmpty) {
        startRow = firstDataRow + i;
        break;
      }
    }
  }
  
  // If we couldn't find an empty row, use the first data row
  if (startRow === -1) {
    startRow = firstDataRow;
    Logger.log("No empty rows found, using first row after header: " + startRow);
  }
  
  Logger.log("Writing " + entries.length + " entries starting at row " + startRow);
  
  // Write each entry
  for (var k = 0; k < entries.length; k++) {
    var currentRow = startRow + k;
    var targetRange = sheet.getRange(currentRow, 5, 1, 6); // Columns E-J (5-10)
    targetRange.setValues([entries[k]]);
    
    // Apply formatting
    sheet.getRange(currentRow, 7, 1, 1).setNumberFormat('MM/dd/yyyy'); // Date column format
    sheet.getRange(currentRow, 8, 1, 1).setNumberFormat('$#,##0.00'); // Commission column format
  }
}

/**
 * Finds the row that contains "Customer Name" in column E
 * @param {SpreadsheetApp.Sheet} sheet - The technician sheet
 * @return {number} The row number (1-based) or -1 if not found
 */
function findCustomerNameHeaderRow(sheet) {
  var lastRow = Math.min(50, sheet.getLastRow()); // Check first 50 rows
  var columnE = sheet.getRange(1, 5, lastRow, 1).getValues();
  
  for (var i = 0; i < columnE.length; i++) {
    var cellValue = columnE[i][0];
    if (cellValue && typeof cellValue === 'string' &&
        cellValue.toString().trim().toLowerCase() === "customer name") {
      return i + 1; // Convert to 1-based row index
    }
  }
  
  return -1; // Not found
} 