/**
 * Functions for handling sheet operations related to lead data.
 */

/**
 * Finds the Lead Set sheet in the spreadsheet.
 * 
 * @param {SpreadsheetApp.Spreadsheet} ss - The spreadsheet to search in.
 * @return {SpreadsheetApp.Sheet|null} The Lead Set sheet or null if not found.
 */
function findLeadSetSheet(ss) {
  try {
    return ss.getSheetByName('Lead Set');
  } catch (error) {
    Logger.log('Error finding Lead Set sheet: ' + error.message);
    return null;
  }
}

/**
 * Gets lead data for a specific technician from the Lead Set sheet.
 * 
 * @param {SpreadsheetApp.Sheet} leadSetSheet - The Lead Set sheet.
 * @param {String} technicianName - The name of the technician.
 * @return {Array} Array of lead data objects.
 */
function getLeadDataForTechnician(leadSetSheet, technicianName) {
  console.log(`Fetching lead data for technician: ${technicianName}`);
  const data = leadSetSheet.getDataRange().getValues();
  
  if (data.length === 0) {
    console.error("Lead Set sheet is empty");
    return [];
  }
  
  const headers = data[0];
  
  // Find column indices by header name instead of hardcoding positions
  let techIndex = -1;
  let customerIndex = -1;
  let unitIndex = -1;
  let dateIndex = -1;
  let revenueIndex = -1;
  
  // Search for column headers
  for (let i = 0; i < headers.length; i++) {
    const header = headers[i] ? headers[i].toString().trim().toLowerCase() : '';
    
    if (header.includes('lead generated') || header.includes('generated by')) {
      techIndex = i;
    } else if (header.includes('customer')) {
      customerIndex = i;
    } else if (header.includes('business unit')) {
      unitIndex = i;
    } else if (header.includes('completion date')) {
      dateIndex = i;
    } else if (header.includes('revenue') || header.includes('total')) {
      revenueIndex = i;
    }
  }
  
  // If we can't find the necessary columns, default to expected positions
  if (techIndex === -1) techIndex = 6;  // Column G - Lead Generated By
  if (customerIndex === -1) customerIndex = 2;  // Column C - Customer Name
  if (unitIndex === -1) unitIndex = 3;  // Column D - Business Unit
  if (dateIndex === -1) dateIndex = 1;  // Column B - Completion Date
  if (revenueIndex === -1) revenueIndex = 4;  // Column E - Job Total Revenue
  
  console.log(`Column indices found: Tech=${techIndex}, Customer=${customerIndex}, Unit=${unitIndex}, CompDate=${dateIndex}, Rev=${revenueIndex}`);
  
  // Debug headers row
  console.log(`Headers row: ${headers.join(' | ')}`);
  
  // Filter data for the specified technician in the Lead Generated By column
  const technicianData = [];
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    
    // Debug first few rows
    if (i < 5) {
      console.log(`Row ${i} lead generated by: "${row[techIndex]}", searching for: "${technicianName}"`);
    }
    
    if (row[techIndex] === technicianName) {
      technicianData.push({
        customer: row[customerIndex],
        businessUnit: row[unitIndex],
        completionDate: row[dateIndex],
        revenue: row[revenueIndex],
        notes: '' // Empty string for notes - will be populated during calculation
      });
    }
  }
  
  console.log(`Found ${technicianData.length} leads for ${technicianName}`);
  return technicianData;
}

/**
 * Writes lead set data to a technician's sheet.
 * Main entry point for writing lead data.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Array} leadData - Array of lead data objects.
 * @return {Boolean} True if successful, false otherwise.
 */
function writeLeadSetDataToSheet(techSheet, leadData) {
  if (!leadData || leadData.length === 0) {
    return true; // Nothing to do, considered successful
  }
  
  // Validate technician sheet structure
  if (!validateSheetStructure(techSheet)) {
    return false;
  }
  
  try {
    // Process data and update the sheet in batches
    const calculatedData = calculateLeadAmounts(leadData);
    clearAndWriteLeadEntries(techSheet, calculatedData.formattedEntries);
    updateLeadSummaryInfo(techSheet, calculatedData.count, calculatedData.total);
    return true;
  } catch (error) {
    Logger.log(`Error writing lead set data: ${error.message}`);
    return false;
  }
}

/**
 * Validates the technician sheet structure for lead operations.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician sheet to validate.
 * @return {Boolean} True if valid, false otherwise.
 */
function validateSheetStructure(techSheet) {
  if (typeof validateTechnicianSheetForLeadSet === 'function' && 
      !validateTechnicianSheetForLeadSet(techSheet)) {
    Logger.log(`Technician sheet ${techSheet.getName()} has invalid structure for lead set operations`);
    return false;
  }
  return true;
}

/**
 * Calculates commission amounts for lead data entries.
 * 
 * @param {Array} leadData - Raw lead data.
 * @return {Object} Processed data with formatted entries, count and total.
 */
function calculateLeadAmounts(leadData) {
  let total = 0;
  const formattedEntries = [];
  
  for (const lead of leadData) {
    // Calculate commission amount
    let amount = 0;
    if (typeof lead.amount === 'number') {
      amount = lead.amount;
    } else if (typeof lead.revenue === 'number' && typeof calculateLeadCommission === 'function') {
      amount = calculateLeadCommission(lead.revenue).amount;
    } else if (typeof lead.revenue === 'number') {
      amount = lead.revenue * 0.05; // 5% fallback
    }
    
    total += amount;
    formattedEntries.push({
      customer: lead.customer || lead.customerName,
      businessUnit: lead.businessUnit || lead.unit,
      completionDate: lead.completionDate || lead.date,
      amount: amount,
      notes: lead.notes || '',
      marker: 'L-E-A-D'
    });
  }
  
  return {
    formattedEntries: formattedEntries,
    count: formattedEntries.length,
    total: total
  };
}

/**
 * Clears existing lead entries and writes new ones in a batch operation.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician sheet.
 * @param {Array} entries - Formatted lead entries to write.
 */
function clearAndWriteLeadEntries(techSheet, entries) {
  // Clear existing entries
  const existingRows = findExistingLeadSetRows(techSheet);
  clearExistingLeadEntries(techSheet, existingRows);
  
  // Prepare data for batch write
  const startRow = findFirstEmptyRow(techSheet);
  const values = entries.map(entry => [
    entry.customer,
    entry.businessUnit,
    entry.completionDate,
    entry.amount,
    entry.notes,
    entry.marker
  ]);
  
  // Write all data at once if we have any
  if (values.length > 0) {
    // Batch write all entries
    techSheet.getRange(startRow, 5, values.length, 6).setValues(values);
    
    // Format cells in batch
    techSheet.getRange(startRow, 8, values.length, 1).setNumberFormat('$#,##0.00');
    techSheet.getRange(startRow, 7, values.length, 1).setNumberFormat('mm/dd/yyyy');
  }
}

/**
 * Updates the lead summary information in the technician's sheet.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Number} leadCount - The number of leads processed.
 * @param {Number} totalCommission - The total commission amount.
 */
function updateLeadSummaryInfo(techSheet, leadCount, totalCommission) {
  try {
    console.log(`Updating lead summary in ${techSheet.getName()}: ${leadCount} leads, $${totalCommission}`);
    
    // Look for the Lead Total row in the payroll sheet (usually around row 18-22)
    const data = techSheet.getRange("A1:A30").getValues();
    let leadTotalRow = -1;
    
    for (let i = 0; i < data.length; i++) {
      const cellValue = data[i][0];
      if (cellValue && typeof cellValue === 'string') {
        const text = cellValue.toString().toLowerCase().trim();
        if (text.includes("lead") && (text.includes("total") || text.includes("pay"))) {
          leadTotalRow = i + 1;
          console.log(`Found Lead Total row at ${leadTotalRow}: "${cellValue}"`);
          break;
        }
      }
    }
    
    // If Lead Total row found, update it
    if (leadTotalRow > 0) {
      // Update count in column B and amount in column C
      techSheet.getRange(leadTotalRow, 2).setValue(leadCount);
      techSheet.getRange(leadTotalRow, 3).setValue(totalCommission).setNumberFormat("$#,##0.00");
      console.log(`Updated Lead Total: Count=${leadCount}, Amount=${totalCommission} at row ${leadTotalRow}`);
    } else {
      // If not found, log a warning but don't stop execution
      console.warn(`Could not find Lead Total row in ${techSheet.getName()}, summary not updated`);
    }
  } catch (error) {
    console.error(`Error in updateLeadSummaryInfo: ${error.message}`);
    console.error(`Stack: ${error.stack}`);
    // Don't throw, this should not stop the main processing
  }
}

/**
 * Finds rows containing "L-E-A-D" in column J.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @return {Array} Array of row indexes (1-based) containing lead entries.
 */
function findExistingLeadSetRows(techSheet) {
  console.log(`Debug: Finding existing lead rows in ${techSheet.getName()}`);
  
  const data = techSheet.getDataRange().getValues();
  const leadRows = [];
  
  // Look for "L-E-A-D" in column J (index 9)
  for (let i = 0; i < data.length; i++) {
    const cellValue = data[i][9]; // Column J (index 9)
    
    // Only log some rows to avoid excessive logging
    if (i < 20 || (cellValue && cellValue.toString().includes('L-E-A-D'))) {
      console.log(`Debug: Row ${i+1}, Column J value: "${cellValue}", type: ${typeof cellValue}`);
    }
    
    // Improved check for L-E-A-D markers
    if (cellValue !== null && cellValue !== undefined) {
      const strValue = cellValue.toString().trim();
      
      // Check both exact match and substring match for maximum robustness
      if (strValue === 'L-E-A-D' || strValue.includes('L-E-A-D')) {
        leadRows.push(i + 1); // +1 for 1-based row index
        console.log(`Debug: Found L-E-A-D marker at row ${i+1}`);
      }
    }
  }
  
  console.log(`Debug: Found total of ${leadRows.length} rows with L-E-A-D markers: ${leadRows.join(', ')}`);
  return leadRows;
}

/**
 * Clears existing lead entries from a technician's sheet.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Array} rowIndexes - Array of row indexes to clear, if not provided will find them.
 */
function clearExistingLeadEntries(techSheet, rowIndexes) {
  // If row indexes not provided, find them
  if (!rowIndexes) {
    rowIndexes = findExistingLeadSetRows(techSheet);
  }
  
  // If no rows to clear, return early
  if (!rowIndexes || rowIndexes.length === 0) {
    return;
  }
  
  // Clear all rows in batch using the batch clearRowsInBatch helper function
  clearRowsInBatch(techSheet, rowIndexes);
}

/**
 * Updates the lead summary information in rows 14-15 of a technician's sheet.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Number} count - The number of leads.
 * @param {Number} total - The total lead payment amount.
 */
function updateTopSummaryLeadSet(techSheet, count, total) {
  // Update row 14, column B with lead count
  techSheet.getRange(14, 2).setValue(count);
  
  // Update row 14, column C with commission information
  const totalCell = techSheet.getRange(14, 3);
  totalCell.setValue(total);
  formatLeadSetCells(totalCell);
  console.log(`DEBUG: Finished updateTopSummaryLeadSet for ${techSheet.getName()}`);
}

/**
 * Writes new lead entries to the technician's sheet.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Array} entries - Array of lead data objects.
 */
function writeNewLeadEntries(techSheet, entries) {
  if (!entries || entries.length === 0) {
    console.log(`Debug: No entries to write to ${techSheet.getName()}`);
    return;
  }
  
  console.log(`DEBUG: Starting writeNewLeadEntries for ${techSheet.getName()} with ${entries.length} entries`);
  
  try {
    // Find where to start writing data (first empty row in the commission section)
    const startRow = findFirstEmptyRow(techSheet);
    console.log(`DEBUG: First empty row found at ${startRow} in ${techSheet.getName()}`);
    
    // Prepare data for batch update
    const values = [];
    
    for (const entry of entries) {
      // Format completion date if it's a Date object
      let formattedDate = entry.completionDate || entry.date || '';
      if (formattedDate instanceof Date) {
        formattedDate = Utilities.formatDate(formattedDate, Session.getScriptTimeZone(), 'MM/dd/yyyy');
      }
      
      // Ensure notes field has a value even if undefined or null
      const notes = entry.notes || 'Lead commission';
      
      // ALWAYS use 'L-E-A-D' in column J for easy identification
      const marker = 'L-E-A-D';
      
      values.push([
        entry.customer || entry.customerName || '',  // Column E: Customer name
        entry.businessUnit || entry.unit || '',      // Column F: Business unit
        formattedDate,                               // Column G: Completion date
        entry.amount || entry.payment || 0,          // Column H: Commission amount
        notes,                                       // Column I: Notes
        marker                                       // Column J: Lead identifier
      ]);
      
      console.log(`DEBUG: Prepared entry for ${entry.customer || entry.customerName || 'Unknown'} with amount: ${entry.amount}, notes: "${notes}", marker: "${marker}"`);
    }
    
    // Check if we have any values to write
    if (values.length === 0) {
      console.log(`DEBUG: No values to write after preparation in ${techSheet.getName()}`);
      return;
    }
    
    // Write all data at once
    techSheet.getRange(startRow, 5, values.length, 6).setValues(values);
    console.log(`DEBUG: Wrote ${values.length} entries at row ${startRow}, columns E-J (5-10) in ${techSheet.getName()}`);
    
    // Format all commission amounts at once
    techSheet.getRange(startRow, 8, values.length, 1).setNumberFormat('$#,##0.00');
    
    // Format all dates at once
    techSheet.getRange(startRow, 7, values.length, 1).setNumberFormat('mm/dd/yyyy');
    
    // Verify the write was successful
    const verifyData = techSheet.getRange(startRow, 10, values.length, 1).getValues();
    let markersFound = 0;
    for (let i = 0; i < verifyData.length; i++) {
      if (verifyData[i][0] === 'L-E-A-D') {
        markersFound++;
      }
    }
    console.log(`DEBUG: Verification - Found ${markersFound}/${values.length} 'L-E-A-D' markers after writing`);
    
  } catch (error) {
    console.error(`ERROR in writeNewLeadEntries: ${error.message}`);
    console.error(`Stack: ${error.stack}`);
  }
}

/**
 * Applies proper formatting to lead set cells.
 * 
 * @param {SpreadsheetApp.Range} range - The range to format.
 */
function formatLeadSetCells(range) {
  if (!range) return;
  
  // Determine what to format based on column
  const column = range.getColumn();
  
  if (column === 8 || column === 3) {
    // Commission amount formatting (column H or C)
    range.setNumberFormat('$#,##0.00');
  } else if (column === 7) {
    // Date formatting (column G)
    range.setNumberFormat('mm/dd/yyyy');
  }
}

/**
 * Finds the first empty row in the commission section of a technician's sheet.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @return {Number} The row number of the first empty row.
 */
function findFirstEmptyRow(techSheet) {
  try {
    console.log(`DEBUG: Finding first empty row in ${techSheet.getName()}`);

    // Dynamically find the header row for the commission data (Columns E-J)
    const headerRow = findCustomerNameHeaderRow(techSheet);
    if (headerRow === -1) {
      console.error(`ERROR: Could not find 'Customer Name' header in column E of sheet ${techSheet.getName()}. Cannot determine where to write data.`);
      return 7; // Fallback to a default row if header not found
    }
    const searchStartRow = headerRow + 1; // Start searching *after* the header row
    console.log(`DEBUG: Found commission header at row ${headerRow}, starting search for empty row at ${searchStartRow}`);

    // First check if we have any L-E-A-D markers to find last occupied row
    // This ensures we don't overwrite existing entries if we're just adding more
    const leadRows = findExistingLeadSetRows(techSheet);
    if (leadRows.length > 0) {
      // Filter lead rows to only include those at or after the searchStartRow
      const relevantLeadRows = leadRows.filter(row => row >= searchStartRow);
      if (relevantLeadRows.length > 0) {
        const lastLeadRow = Math.max(...relevantLeadRows);
        const nextRow = lastLeadRow + 1;
        console.log(`DEBUG: Found L-E-A-D entries, last relevant entry at row ${lastLeadRow}, using next row ${nextRow}`);
        return nextRow;
      } else {
        // If existing leads are *before* the header (unlikely, but possible), start after header
        console.log(`DEBUG: Found L-E-A-D entries, but all are before the search start row ${searchStartRow}. Using search start row.`);
        // Fall through to the next check, starting at searchStartRow
      }
    }

    // If no relevant lead entries found, look for *any* data in columns E-J starting from searchStartRow
    const lastRow = techSheet.getLastRow();
    // Ensure we don't try to read negative rows if lastRow < searchStartRow
    const rowsToCheck = Math.max(0, lastRow - searchStartRow + 1); 

    if (rowsToCheck > 0) {
      console.log(`DEBUG: No relevant lead entries found. Checking ${rowsToCheck} rows for any data from row ${searchStartRow} to ${lastRow} in columns E-J`);

      // Get all data in columns E-J for the search range
      const data = techSheet.getRange(searchStartRow, 5, rowsToCheck, 6).getValues();

      // Find the last row with any data in columns E-J within the searched range
      let lastDataRowIndex = -1; // Index relative to the 'data' array
      for (let i = 0; i < data.length; i++) {
        const row = data[i];
        // More robust check for any content
        const hasData = row.some(cell => {
          return cell !== null && cell !== undefined && cell !== '' &&
                 !(typeof cell === 'string' && cell.trim() === '');
        });

        if (hasData) {
          // console.log(`DEBUG: Found data at relative index ${i} (actual row ${searchStartRow + i}), contents: [${row.join(' | ')}]`);
          lastDataRowIndex = i;
        }
      }

      // Return the row immediately after the last data row found in the range
      if (lastDataRowIndex !== -1) {
        const actualLastDataRow = searchStartRow + lastDataRowIndex;
        const nextRow = actualLastDataRow + 1;
        console.log(`DEBUG: Found last data row at ${actualLastDataRow}, using next row: ${nextRow}`);
        return nextRow;
      }

      // If no data was found in the range, use the starting search row
      console.log(`DEBUG: No data found in columns E-J from row ${searchStartRow} onwards, using starting row: ${searchStartRow}`);
      return searchStartRow;
    }

    // If no rows to check (e.g., sheet is empty after header), use the starting search row
    console.log(`DEBUG: No rows to check after header (lastRow=${lastRow}, searchStartRow=${searchStartRow}), using starting row: ${searchStartRow}`);
    return searchStartRow;

  } catch (error) {
    console.error(`ERROR in findFirstEmptyRow: ${error.message}`);
    console.error(`Stack: ${error.stack}`);
    // Default to a safe row if there's an error
    return 7; // Fallback to row 7 in case of unexpected error
  }
}

/**
 * Finds the row that contains "Customer Name" in column E
 * @param {SpreadsheetApp.Sheet} sheet - The technician sheet
 * @return {number} The row number (1-based) or -1 if not found
 */
function findCustomerNameHeaderRow(sheet) {
  var lastRow = Math.min(50, sheet.getLastRow()); // Check first 50 rows
  var columnE = sheet.getRange(1, 5, lastRow, 1).getValues();
  
  for (var i = 0; i < columnE.length; i++) {
    var cellValue = columnE[i][0];
    if (cellValue && typeof cellValue === 'string' &&
        cellValue.toString().trim().toLowerCase() === "customer name") {
      return i + 1; // Convert to 1-based row index
    }
  }
  
  return -1; // Not found
}

/**
 * Processes all lead set data for all technicians.
 * This function is called from the "All Lead Set" menu item.
 */
function processAllLeadSets() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ui = SpreadsheetApp.getUi();
    
    // Find the Lead Set sheet
    const leadSetSheet = findLeadSetSheet(ss);
    if (!leadSetSheet) {
      ui.alert('Error: Could not find "Lead Set" sheet.');
      return;
    }
    
    // Get all technician names from the Hourly + Spiff Pay sheet
    const ratesSheet = ss.getSheetByName('Hourly + Spiff Pay');
    if (!ratesSheet) {
      ui.alert('Error: Could not find "Hourly + Spiff Pay" sheet.');
      return;
    }
    
    // Get rates sheet mapping
    const ratesMapping = getRatesSheetMapping();
    const dataRange = ratesSheet.getRange(
      ratesMapping.dataStartRow, 
      ratesMapping.nameColumn, 
      ratesSheet.getLastRow() - ratesMapping.dataStartRow + 1, 
      1
    );
    
    const technicianNames = dataRange.getValues().flat().filter(name => 
      name && typeof name === 'string' && name.trim() !== ''
    );
    
    if (technicianNames.length === 0) {
      ui.alert('No technicians found in Hourly + Spiff Pay sheet.');
      return;
    }
    
    let processedCount = 0;
    let skippedCount = 0;
    const processedTechs = [];
    const skippedTechs = [];
    
    // Process each technician
    for (const techName of technicianNames) {
      const techSheet = ss.getSheetByName(techName);
      
      if (!techSheet) {
        skippedTechs.push(techName + ' (Sheet not found)');
        skippedCount++;
        continue;
      }
      
      try {
        // Get lead data for this technician
        const leadData = getLeadDataForTechnician(leadSetSheet, techName);
        
        // Write the lead data to the technician's sheet
        writeLeadSetDataToSheet(techSheet, leadData);
        
        processedTechs.push(techName);
        processedCount++;
      } catch (err) {
        skippedTechs.push(techName + ': ' + err.message);
        skippedCount++;
        Logger.log("Error processing " + techName + ": " + err.message);
      }
    }
    
    // Display summary message
    const summaryMessage = `LEAD SET PROCESSING COMPLETE

SUMMARY:
• Processed: ${processedCount} technicians
${processedCount > 0 ? '• ' + processedTechs.join(', ') : ''}
${skippedCount > 0 ? '\nSkipped: ' + skippedCount + ' technicians\n• ' + skippedTechs.join('\n• ') : ''}`;
    
    ui.alert(summaryMessage);
    
  } catch (e) {
    Logger.log("Error in processAllLeadSets: " + e.message);
    SpreadsheetApp.getUi().alert("Error processing lead sets: " + e.message);
  }
}

/**
 * Gets the field mappings for the Hourly + Spiff Pay sheet
 * @return {Object} An object containing column indexes for important fields
 */
function getRatesSheetMapping() {
  return {
    nameColumn: 1,       // Column A - Technician name
    positionColumn: 2,   // Column B - Position
    rateColumn: 4,       // Column D - Base Rate
    actionColumn: 7,     // Column G - Action column
    dataStartRow: 3      // Data starts at row 3
  };
}

/**
 * Finds the row where the Install Customer Data section starts.
 * @param {SpreadsheetApp.Sheet} sheet - The sheet to search in.
 * @return {number} The row number (1-based) or -1 if not found.
 */
function findInstallCustomerDataSection(sheet) {
  if (!sheet) return -1;
  console.log(`Debug: Searching for Install section in sheet: ${sheet.getName()}`);
  
  var data = sheet.getRange("A1:A50").getValues(); // Search first 50 rows
  
  // First attempt: Exact match
  for (var i = 0; i < data.length; i++) {
    var value = data[i][0];
    if (value && typeof value === "string") {
      var trimmedValue = value.trim();
      console.log(`Debug: Row ${i+1}, Column A value: "${trimmedValue}"`);
      
      if (trimmedValue === "Install [Customer Data]" || 
          trimmedValue === "Install Customer Data" || 
          trimmedValue === "Install & Sales") { 
        console.log(`Debug: Found install section: '${trimmedValue}' at row ${i+1}`);
        return i + 1; 
      }
    }
  }
  
  // Fallback search (case-insensitive, partial, within first 50 rows)
  console.log(`Debug: No exact Install section match found, trying partial matches`);
  for (var i = 0; i < data.length; i++) {
     var value = data[i][0];
     if (value && typeof value === "string") {
       var lowerValue = value.toLowerCase().trim();
       if (lowerValue.includes("install") && 
           (lowerValue.includes("customer") || 
            lowerValue.includes("data") || 
            lowerValue.includes("sales") || 
            lowerValue.includes("&"))) {
         console.log(`Debug: Found install section using partial match: '${value}' at row ${i+1}`);
         return i + 1;
       }
     }
  }
  
  console.log(`Debug: No Install section header found in sheet: ${sheet.getName()}`);
  return -1;
}

/**
 * Finds the row where the next section after Install starts.
 * @param {SpreadsheetApp.Sheet} sheet - The sheet to search in.
 * @param {number} installSectionRow - The row where the Install section starts.
 * @return {number} The row number (1-based) or -1 if not found.
 */
function findNextSectionAfterInstall(sheet, installSectionRow) {
  if (!sheet || installSectionRow <= 0) return -1;
  console.log(`Debug: Searching for next section after Install section (row ${installSectionRow})`);
  
  var startSearchRow = installSectionRow + 3; // Start looking below header/first data
  var maxSearchRow = Math.min(sheet.getLastRow() + 1, installSectionRow + 60); // Search up to 60 rows after install
  
  console.log(`Debug: Will search from row ${startSearchRow} to row ${maxSearchRow-1}`);
  
  if (startSearchRow >= maxSearchRow) {
    console.log(`Debug: Search range is empty or invalid`);
    return -1;
  }

  var searchValues = sheet.getRange(startSearchRow, 1, maxSearchRow - startSearchRow, 1).getValues();
  
  for (var i = 0; i < searchValues.length; i++) {
    var rowValue = searchValues[i][0];
    var actualRow = startSearchRow + i;
    
    if (rowValue && typeof rowValue === "string") {
      var trimmedValue = rowValue.trim();
      var lowerValue = trimmedValue.toLowerCase();
      
      console.log(`Debug: Row ${actualRow}, Column A value: "${trimmedValue}"`);
      
      // Look for non-empty cells that don't seem like data continuation or total rows
      if (trimmedValue.length > 0 && 
          !lowerValue.includes("install") && 
          !lowerValue.includes("total")) {
          
        // Simple check: If it contains common section words or ends with 'Data]'?
        if (lowerValue.includes("data") || 
            lowerValue.includes("sales") || 
            lowerValue.includes("spiff") || 
            lowerValue.includes("bonus") || 
            lowerValue.includes("lead") || 
            lowerValue.includes("customer") || 
            trimmedValue.endsWith("Data]")) {
            
          console.log(`Debug: Found next section header '${trimmedValue}' at row ${actualRow}`);
          return actualRow;
        }
      }
    }
  }
  
  console.log(`Debug: No next section found after Install section in sheet: ${sheet.getName()}`);
  return -1;
}

/**
 * Clears lead data in the Installation section of the technician sheet.
 * This includes marking (L-E-A-D), commission amount, and notes columns.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @return {Number} The number of rows cleared.
 */
function clearLeadDataInInstallSection(techSheet) {
  try {
    console.log(`Starting to clear lead data in ${techSheet.getName()}`);
    
    // Find Installation section
    const data = techSheet.getDataRange().getValues();
    let installRowStart = -1;
    
    for (let i = 0; i < data.length; i++) {
      if (data[i][0] === 'Installation') {
        installRowStart = i;
        console.log(`Found Installation section at row ${installRowStart + 1}`);
        break;
      } else if (i < 20) {
        console.log(`Debug: Checking row ${i+1}, value: "${data[i][0]}"`);
      }
    }
    
    if (installRowStart === -1) {
      // Try alternative search for Installation section
      for (let i = 0; i < Math.min(30, data.length); i++) {
        if (data[i][0] && typeof data[i][0] === 'string' && 
            data[i][0].toString().toLowerCase().includes('install')) {
          installRowStart = i;
          console.log(`Found Installation section (partial match) at row ${installRowStart + 1}: "${data[i][0]}"`);
          break;
        }
      }
      
      if (installRowStart === -1) {
        console.error(`Installation section not found in ${techSheet.getName()}`);
        return 0;
      }
    }
    
    // Find all rows with L-E-A-D marker in column J (index 9)
    let leadRows = [];
    let totalRowsSearched = 0;
    
    for (let i = installRowStart; i < data.length && i < installRowStart + 100; i++) {
      totalRowsSearched++;
      // Log column J value for debugging
      if (i < installRowStart + 10 || data[i][9] === 'L-E-A-D' || 
          (data[i][9] && data[i][9].toString().includes('L-E-A-D'))) {
        console.log(`Debug: Row ${i+1}, Column J value: "${data[i][9]}", type: ${typeof data[i][9]}`);
      }
      
      if (data[i][9] === 'L-E-A-D' || 
          (data[i][9] && typeof data[i][9] === 'string' && data[i][9].toString().includes('L-E-A-D'))) {
        leadRows.push(i + 1);  // +1 for 1-indexed sheet rows
      }
    }
    
    console.log(`Debug: Searched ${totalRowsSearched} rows, found ${leadRows.length} rows with L-E-A-D markers`);
    if (leadRows.length > 0) {
      console.log(`Debug: Lead rows found at: ${leadRows.join(', ')}`);
    }
    
    // Clear each lead row (columns J, K, I for marker, commission, notes)
    leadRows.forEach(row => {
      techSheet.getRange(row, 10).clearContent();  // Column J - Marker
      techSheet.getRange(row, 11).clearContent();  // Column K - Commission
      techSheet.getRange(row, 9).clearContent();   // Column I - Notes
      console.log(`Cleared lead data in row ${row}`);
    });
    
    return leadRows.length;
  } catch (error) {
    console.error(`Error in clearLeadDataInInstallSection: ${error.message}`);
    console.error(`Stack: ${error.stack}`);
    throw error;  // Re-throw to be handled by caller
  }
}

/**
 * Finds all rows in a sheet containing L-E-A-D markers in column J.
 * 
 * @param {SpreadsheetApp.Sheet} sheet - The sheet to search in.
 * @return {number[]} Array of row numbers (1-based) containing L-E-A-D markers.
 */
function findRowsWithLeadMarkers(sheet) {
  // Get all values in column J
  const columnJ = sheet.getRange(1, 10, sheet.getLastRow(), 1).getValues();
  
  // Find rows with L-E-A-D in column J
  const rowsToClean = [];
  for (let i = 0; i < columnJ.length; i++) {
    const cellValue = columnJ[i][0];
    if (cellValue && typeof cellValue === 'string' && cellValue.includes('L-E-A-D')) {
      rowsToClean.push(i + 1); // Add 1 for 1-based row index
    }
  }
  
  return rowsToClean;
}

/**
 * Clears content from columns E-J for the specified rows in batch.
 * 
 * @param {SpreadsheetApp.Sheet} sheet - The sheet to modify.
 * @param {number[]} rowNumbers - Array of row numbers to clear.
 */
function clearRowsInBatch(sheet, rowNumbers) {
  // Process rows in batches for larger sets
  const batchSize = 20;
  
  for (let i = 0; i < rowNumbers.length; i += batchSize) {
    const batch = rowNumbers.slice(i, i + batchSize);
    batch.forEach(row => {
      // Ensure the row number is valid before attempting to clear
      if (row > 0 && row <= sheet.getMaxRows()) { 
        try {
          sheet.getRange(row, 5, 1, 6).clearContent(); // Clear columns E-J (5-10)
        } catch (e) {
          Logger.log(`Error clearing content in row ${row}, columns E-J of sheet ${sheet.getName()}: ${e.message}`);
          // Optionally, add more robust error handling or logging
        }
      } else {
        Logger.log(`Skipping invalid row number ${row} for clearing content in sheet ${sheet.getName()}`);
      }
    });
  }
}

/**
 * Smart data writing function that reuses existing rows when possible.
 * Updates technician sheet with lead data in an efficient way.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Array} leadEntries - The lead entries to write.
 * @param {Number} totalAmount - The total lead commission amount.
 */
function smartWriteLeadDataToSheet(techSheet, leadEntries, totalAmount) {
  if (!techSheet) {
    Logger.log("Cannot write lead data: invalid technician sheet");
    return;
  }
  
  // 1. Update top summary
  updateTopSummaryLeadSet(techSheet, leadEntries.length, totalAmount);
  
  // 2. Find existing LEAD rows
  const existingLeadRows = findExistingLeadSetRows(techSheet);
  
  // 3. Prepare data for writing
  const dataToWrite = prepareLeadDataForWrite(leadEntries);
  
  // 4. Write data to the sheet
  if (dataToWrite.length === 0) {
    Logger.log("No lead data to write");
    return;
  }
  
  // Handle the data writing based on existing rows
  if (existingLeadRows.length > 0) {
    updateExistingAndAddNewLeadRows(techSheet, existingLeadRows, dataToWrite);
  } else {
    writeRemainingLeadEntries(techSheet, dataToWrite);
  }
  
  Logger.log("Smart update finished for: " + techSheet.getName());
}

/**
 * Prepares lead entry data for writing to the sheet.
 * 
 * @param {Array} leadEntries - The lead entries to prepare.
 * @return {Array} Formatted data ready for sheet insertion.
 */
function prepareLeadDataForWrite(leadEntries) {
  const dataToWrite = [];
  
  for (let i = 0; i < leadEntries.length; i++) {
    const entry = leadEntries[i];
    let dateStr = "";
    
    // Format date if needed
    if (entry.completionDate) {
      if (entry.completionDate instanceof Date) {
        dateStr = Utilities.formatDate(entry.completionDate, 
                                     Session.getScriptTimeZone(), 
                                     "MM/dd/yyyy");
      } else {
        dateStr = entry.completionDate.toString();
      }
    }
    
    dataToWrite.push([
      entry.customer || entry.customerName || "",  // Column E: Customer name
      entry.businessUnit || entry.unit || "",      // Column F: Business unit
      dateStr,                                     // Column G: Completion date
      entry.amount || entry.payment || 0,          // Column H: Commission amount
      entry.notes || "",                           // Column I: Notes
      "L-E-A-D"                                    // Column J: Lead identifier
    ]);
  }
  
  return dataToWrite;
}

/**
 * Updates existing lead rows and adds new ones if needed.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Array} existingLeadRows - Row numbers of existing lead rows.
 * @param {Array} dataToWrite - Formatted data to write.
 */
function updateExistingAndAddNewLeadRows(techSheet, existingLeadRows, dataToWrite) {
  Logger.log("Found " + existingLeadRows.length + " existing LEAD rows to update");
  
  // The number of rows we need to update
  const rowsToUpdate = Math.min(existingLeadRows.length, dataToWrite.length);
  
  // Update existing rows first
  for (let i = 0; i < rowsToUpdate; i++) {
    const targetRow = existingLeadRows[i];
    const targetRange = techSheet.getRange(targetRow, 5, 1, 6); // Columns E-J (5-10)
    targetRange.setValues([dataToWrite[i]]);
  }
  
  // If we have more entries than existing lead rows, find empty rows for the rest
  if (dataToWrite.length > existingLeadRows.length) {
    const remainingEntries = dataToWrite.slice(existingLeadRows.length);
    writeRemainingLeadEntries(techSheet, remainingEntries);
  }
  
  // If we have fewer entries than existing lead rows, clear the excess rows
  if (existingLeadRows.length > dataToWrite.length) {
    Logger.log("Clearing " + (existingLeadRows.length - dataToWrite.length) + " excess L-E-A-D rows");
    clearExcessLeadRows(techSheet, existingLeadRows, dataToWrite.length);
  }
}

/**
 * Clears excess lead rows that are no longer needed.
 * 
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Array} existingLeadRows - Row numbers of existing lead rows.
 * @param {Number} usedRowCount - Number of rows that have been used/updated.
 */
function clearExcessLeadRows(techSheet, existingLeadRows, usedRowCount) {
  for (let j = usedRowCount; j < existingLeadRows.length; j++) {
    const excessRow = existingLeadRows[j];
    techSheet.getRange(excessRow, 5, 1, 6).clearContent();
  }
}

/**
 * Writes lead entries to empty rows in the sheet.
 * Used as part of the smartWriteLeadDataToSheet function.
 * 
 * @param {SpreadsheetApp.Sheet} sheet - The technician sheet.
 * @param {Array} entries - The formatted lead entries to write.
 */
function writeRemainingLeadEntries(sheet, entries) {
  if (!entries || entries.length === 0) return;
  
  // Find the header row with "Customer Name" in column E
  var headerRow = findCustomerNameHeaderRow(sheet);
  if (headerRow <= 0) {
    Logger.log("Could not find 'Customer Name' header in column E in " + sheet.getName());
    return;
  }
  
  // Start looking at the row after the header
  var firstDataRow = headerRow + 1;
  var lastRow = sheet.getLastRow();
  
  // Find first empty row in columns E-J
  var startRow = -1;
  var rowsToSearch = Math.min(50, lastRow - firstDataRow + 1); // Cap at 50 rows
  
  if (rowsToSearch > 0) {
    var rowData = sheet.getRange(firstDataRow, 5, rowsToSearch, 6).getValues(); // Columns E-J (5-10)
    
    for (var i = 0; i < rowData.length; i++) {
      var isEmpty = true;
      for (var j = 0; j < rowData[i].length; j++) {
        if (rowData[i][j] !== "") {
          isEmpty = false;
          break;
        }
      }
      
      if (isEmpty) {
        startRow = firstDataRow + i;
        break;
      }
    }
  }
  
  // If we couldn't find an empty row, use the first data row
  if (startRow === -1) {
    startRow = firstDataRow;
    Logger.log("No empty rows found, using first row after header: " + startRow);
  }
  
  Logger.log("Writing " + entries.length + " entries starting at row " + startRow);
  
  // Write each entry
  for (var k = 0; k < entries.length; k++) {
    var currentRow = startRow + k;
    var targetRange = sheet.getRange(currentRow, 5, 1, 6); // Columns E-J (5-10)
    targetRange.setValues([entries[k]]);
    
    // Apply formatting
    sheet.getRange(currentRow, 7, 1, 1).setNumberFormat('MM/dd/yyyy'); // Date column format
    sheet.getRange(currentRow, 8, 1, 1).setNumberFormat('$#,##0.00'); // Commission column format
  }
}

/**
 * Processes lead set data and writes relevant leads to the technician's sheet.
 * 
 * @param {SpreadsheetApp.Sheet} leadSetSheet - The Lead Set sheet.
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {String} technicianName - The name of the technician.
 * @return {Object} Object containing processing results.
 */
function processAndWriteLeadData(leadSetSheet, techSheet, technicianName) {
  try {
    console.log(`Processing lead data for ${technicianName}`);

    // Clear ALL existing L-E-A-D entries first
    try {
      console.log(`Clearing all existing L-E-A-D entries for ${technicianName}`);
      clearExistingLeadEntries(techSheet); // Use the general clearing function
    } catch (clearError) {
      // Log a warning but continue if clearing fails for some reason
      console.error(`Warning: Error clearing existing L-E-A-D entries: ${clearError.message}. Proceeding anyway.`);
    }
    
    // Validate Lead Set sheet
    if (typeof validateLeadSetSheet === 'function') {
      const validation = validateLeadSetSheet(leadSetSheet);
      if (!validation.valid) {
        const errorMsg = `Lead Set sheet validation failed: ${validation.reason}`;
        console.error(errorMsg);
        return { success: false, error: errorMsg };
      }
      console.log('Lead Set sheet validation passed');
    }
    
    // Extract and process leads
    const leads = getLeadDataForTechnician(leadSetSheet, technicianName);
    console.log(`Extracted ${leads.length} leads for ${technicianName}`);
    
    if (leads.length === 0) {
      return { 
        success: true, 
        leadsProcessed: 0, 
        totalCommission: 0, 
        processedLeads: []
      };
    }
    
    // Calculate commissions
    let processedLeads = [];
    let totalCommission = 0;
    
    if (typeof calculateLeadCommissions === 'function') {
      const result = calculateLeadCommissions(leads);
      processedLeads = result.processedLeads;
      totalCommission = result.totalCommission;
    } else {
      // Fallback if calculateLeadCommissions doesn't exist
      processedLeads = leads.map(lead => {
        const amount = lead.amount || (lead.revenue ? lead.revenue * 0.05 : 0); // 5% default
        return {
          ...lead,
          amount: amount
        };
      });
      totalCommission = processedLeads.reduce((sum, lead) => sum + (lead.amount || 0), 0);
    }
    
    console.log(`Calculated commission total: $${totalCommission} for ${processedLeads.length} leads`);
    
    // Prepare data for writing
    const leadDataToWrite = processedLeads.map(lead => [
      lead.customerName || lead.customer || '',  // Column E (5): Customer name
      lead.businessUnit || lead.unit || '',      // Column F (6): Business unit 
      lead.completionDate || '',                 // Column G (7): Completion date
      lead.amount || 0,                          // Column H (8): Commission amount
      lead.notes || 'Lead commission',           // Column I (9): Notes
      'L-E-A-D'                                  // Column J (10): Lead identifier
    ]);
    
    console.log(`Prepared ${leadDataToWrite.length} entries for writing`);
    
    // Find the insertion point - use the first empty row after the customer name header
    const startRow = findFirstEmptyRow(techSheet);
    console.log(`Found insertion point at row ${startRow}`);
    
    if (leadDataToWrite.length > 0) {
      // Write all lead data at once in a batch operation
      try {
        techSheet.getRange(startRow, 5, leadDataToWrite.length, 6).setValues(leadDataToWrite);
        console.log(`Successfully wrote ${leadDataToWrite.length} leads starting at row ${startRow}, columns E-J`);
        
        // Format cells
        techSheet.getRange(startRow, 8, leadDataToWrite.length, 1).setNumberFormat('$#,##0.00'); // Column H - Amount
        techSheet.getRange(startRow, 7, leadDataToWrite.length, 1).setNumberFormat('mm/dd/yyyy'); // Column G - Date
        
        // Verify the write was successful
        const markerColumn = techSheet.getRange(startRow, 10, leadDataToWrite.length, 1).getValues();
        let markersFound = 0;
        for (let i = 0; i < markerColumn.length; i++) {
          if (markerColumn[i][0] === 'L-E-A-D') {
            markersFound++;
          }
        }
        console.log(`Verification: Found ${markersFound}/${leadDataToWrite.length} 'L-E-A-D' markers after writing`);
      } catch (writeError) {
        console.error(`Error writing lead data: ${writeError.message}`);
        console.error(`Stack: ${writeError.stack}`);
        return { success: false, error: `Error writing lead data: ${writeError.message}` };
      }
    }
    
    // Update summary information
    try {
      updateTopSummaryLeadSet(techSheet, processedLeads.length, totalCommission);
      console.log(`Updated lead summary information (Top): ${processedLeads.length} leads, $${totalCommission} total`);
    } catch (summaryError) {
      console.error(`Warning: Error updating top summary: ${summaryError.message}`);
      // Continue anyway
    }
    
    return {
      success: true,
      leadsProcessed: processedLeads.length,
      totalCommission: totalCommission,
      processedLeads: processedLeads
    };
  } catch (error) {
    console.error(`Error in processAndWriteLeadData: ${error.message}`);
    console.error(`Stack: ${error.stack}`);
    throw error;  // Re-throw to be handled by caller
  }
} 