/**
 * Call-By-Call_% - Technician KPI Data Pull from Supabase
 * 
 * Pulls technician KPI scores from Supabase job_analysis_summary table
 * and writes to each technician's payroll sheet (B15: score, C15: bonus).
 */

var Modules = Modules || {};
Modules.TechKPI = Modules.TechKPI || {};

// In-memory cache for KPI data
globalThis._kpiDataCache = globalThis._kpiDataCache || null;

/**
 * Fetches data from Supabase
 */
function fetchSupabaseData(startDate, endDate) {
  const scriptProps = PropertiesService.getScriptProperties();
  let supabaseUrl = scriptProps.getProperty('SUPABASE_URL');
  let supabaseKey = scriptProps.getProperty('SUPABASE_API_KEY');
  
  // Default configuration
  if (!supabaseUrl) {
    supabaseUrl = 'https://yhfquopntmoptqovgmed.supabase.co';
    scriptProps.setProperty('SUPABASE_URL', supabaseUrl);
  }
  
  if (!supabaseKey) {
    supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InloZnF1b3BudG1vcHRxb3ZnbWVkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTExNDQ1NTAsImV4cCI6MjA2NjcyMDU1MH0.M1nDM5KCCi2yrLF1xtLpWACow9fl1JJBrhbVaRjN4lI';
    scriptProps.setProperty('SUPABASE_API_KEY', supabaseKey);
  }
  
  // Query with date range filter
  const endpoint = `${supabaseUrl}/rest/v1/job_analysis_summary`;
  const url = `${endpoint}?select=*&date_dispatched=gte.${startDate}&date_dispatched=lte.${endDate}&order=date_dispatched.desc`;
  
  const options = {
    'method': 'GET',
    'headers': {
      'apikey': supabaseKey,
      'Authorization': `Bearer ${supabaseKey}`,
      'Content-Type': 'application/json',
      'Prefer': 'return=representation'
    },
    'muteHttpExceptions': true
  };
  
  try {
    console.log(`Fetching KPI data for ${startDate} to ${endDate}`);
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode !== 200) {
      console.error(`Supabase API error: ${responseCode}`);
      throw new Error(`Failed to fetch data: ${responseCode}`);
    }
    
    const data = JSON.parse(response.getContentText());
    console.log(`Fetched ${data.length} records`);
    return data;
  } catch (error) {
    console.error(`Error fetching from Supabase: ${error.message}`);
    throw error;
  }
}

/**
 * Process KPI for a single technician
 */
Modules.TechKPI.processForTechnician = function(techName) {
  return pullTechnicianKPI(techName);
};

/**
 * Batch-process KPI for all technicians
 */
Modules.TechKPI.processAll = function(technicianList) {
  try {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var mainName = (Modules.Constants && Modules.Constants.SHEET && Modules.Constants.SHEET.MAIN) || 'Main';
    var mainSheet = ss.getSheetByName(mainName);
    if (!mainSheet) return;

    var allSheets = ss.getSheets();
    var sheetNames = allSheets.map(function(sheet) {
      return sheet.getName();
    });

    var techniciansToProcess = [];
    if (Array.isArray(technicianList) && technicianList.length > 0) {
      techniciansToProcess = technicianList.filter(function(name) {
        return sheetNames.indexOf(name) !== -1;
      });
    } else {
      var data = mainSheet.getRange(2, 1, mainSheet.getLastRow() - 1, 1).getValues();
      var names = data.map(function(r){return String(r[0]).trim();}).filter(Boolean);
      
      techniciansToProcess = names.filter(function(name) {
        return sheetNames.indexOf(name) !== -1;
      });
    }

    var processed = 0;
    techniciansToProcess.forEach(function(name) {
      try {
        pullTechnicianKPI(name);
        processed++;
      } catch (err) {
        console.error("Error processing KPI for " + name + ": " + err.message);
      }
    });
    
    console.log("Completed KPI processing for " + processed + " technicians");
    
    if (Modules && Modules.Shared && Modules.Shared.Progress && 
        typeof Modules.Shared.Progress.log === 'function') {
      Modules.Shared.Progress.log("Processed Call By Call Score for " + processed + " technicians");
    }
  } catch (err) {
    if (Modules.Shared && Modules.Shared.PayrollLogger) {
      Modules.Shared.PayrollLogger.error('TechKPI.processAll error:', err);
    } else {
      console.error('TechKPI.processAll error: ' + err);
    }
  }
};

/**
 * Main function to pull and calculate KPI for a technician
 */
function pullTechnicianKPI(techName) {
  try {
    const startTime = Date.now();
    console.log(`Processing KPI for ${techName}`);
    
    // Temporary: Clear cache to ensure fresh data after score recalculation
    // Remove this line after confirming scores are correct
    globalThis._kpiDataCache = null;
    
    const payrollSS = SpreadsheetApp.getActiveSpreadsheet();
    var mainSheetName = (Modules.Constants && Modules.Constants.SHEET && Modules.Constants.SHEET.MAIN) || 'Main';
    
    // Get pay period from Main sheet F1
    let periodStr;
    try {
      periodStr = payrollSS.getSheetByName(mainSheetName).getRange('F1').getDisplayValue();
      console.log(`Pay period: ${periodStr}`);
    } catch (periodErr) {
      console.warn(`Error getting pay period: ${periodErr.message}`);
      periodStr = "";
    }
    
    // Parse date range
    let start, end;
    try {
      const parsedDates = parseDateRange(periodStr);
      start = parsedDates.start;
      end = parsedDates.end;
    } catch (dateErr) {
      console.warn(`Error parsing date range: ${dateErr.message}`);
      end = new Date();
      start = new Date();
      start.setDate(start.getDate() - 7);
    }
    
    // Format dates for Supabase
    const startDateStr = Utilities.formatDate(start, Session.getScriptTimeZone(), 'yyyy-MM-dd');
    const endDateStr = Utilities.formatDate(end, Session.getScriptTimeZone(), 'yyyy-MM-dd');
    
    // Check cache or fetch fresh data
    const cacheKey = `${startDateStr}_${endDateStr}`;
    if (!globalThis._kpiDataCache || globalThis._kpiDataCache.key !== cacheKey) {
      try {
        const supabaseData = fetchSupabaseData(startDateStr, endDateStr);
        
        // Index by technician name
        const indexByTech = {};
        supabaseData.forEach(function(row) {
          const techNameLower = (row.tech_name || '').trim().toLowerCase();
          if (!techNameLower) return;
          
          if (!indexByTech[techNameLower]) {
            indexByTech[techNameLower] = [];
          }
          indexByTech[techNameLower].push(row);
        });
        
        globalThis._kpiDataCache = {
          key: cacheKey,
          data: supabaseData,
          index: indexByTech,
          loadedAt: Date.now()
        };
        
        console.log(`Cached data for ${Object.keys(indexByTech).length} technicians`);
      } catch (error) {
        console.error(`Failed to fetch data: ${error.message}`);
        const techSh = payrollSS.getSheetByName(techName);
        if (techSh) {
          techSh.getRange('B15').setValue(0);
          techSh.getRange('C15').setValue(0);
        }
        return 0;
      }
    } else {
      console.log('Using cached data');
    }
    
    // Calculate average score for technician
    const techNameLower = techName.trim().toLowerCase();
    const techData = (globalThis._kpiDataCache.index[techNameLower] || []);
    
    let sum = 0, count = 0;
    let skippedZeros = 0;
    
    techData.forEach(function(row) {
      const pct = parsePercentage(row.score || 0);
      
      if (isNaN(pct)) return;
      
      // Skip zeros in average calculation
      if (pct === 0) {
        skippedZeros++;
        return;
      }
      
      sum += pct;
      count++;
    });
    
    // Calculate average
    const avg = count > 0 ? sum / count : 0;
    
    console.log(`${techName}: ${count} valid entries (skipped ${skippedZeros} zeros), avg: ${(avg * 100).toFixed(1)}%`);
    
    // Write to technician sheet
    const techSh = payrollSS.getSheetByName(techName);
    
    if (techSh) {
      try {
        techSh.getRange('B15').setValue(avg);
        
        // Apply bonus if score > 90%
        if (avg > 0.9) {
          techSh.getRange('C15').setValue(100);
          console.log(`$100 bonus for ${techName} (${(avg * 100).toFixed(1)}%)`);
        } else {
          techSh.getRange('C15').setValue(0);
        }
      } catch (sheetErr) {
        console.error(`Error writing to sheet: ${sheetErr.message}`);
      }
    } else {
      console.warn(`Sheet not found for ${techName}`);
    }
    
    console.log(`Completed in ${Date.now() - startTime}ms`);
    return avg;
    
  } catch (error) {
    console.error(`Error in pullTechnicianKPI: ${error.message}`);
    
    try {
      const payrollSS = SpreadsheetApp.getActiveSpreadsheet();
      const techSh = payrollSS.getSheetByName(techName);
      if (techSh) {
        techSh.getRange('B15').setValue(0);
        techSh.getRange('C15').setValue(0);
      }
    } catch (e) {
      console.error(`Failed to update sheet: ${e.message}`);
    }
    
    return 0;
  }
}

/**
 * Parse percentage values from various formats
 */
function parsePercentage(value) {
  if (value === null || value === undefined) return 0;
  
  if (typeof value === 'number') {
    if (value > 1) return value / 100;
    return value; 
  }
  
  if (typeof value === 'string') {
    value = value.replace('%', '').trim();
    const parsed = parseFloat(value);
    
    if (!isNaN(parsed)) {
      if (parsed > 1) return parsed / 100;
      return parsed;
    }
  }
  
  return NaN;
}

/**
 * Parse date range from format "MM/DD - MM/DD" or "MM/DD/YY - MM/DD/YY"
 */
function parseDateRange(rangeStr) {
  try {
    if (!rangeStr || typeof rangeStr !== 'string') {
      throw new Error('Invalid date range');
    }
    
    rangeStr = rangeStr.trim();
    
    let parts;
    if (rangeStr.includes(' - ')) {
      parts = rangeStr.split(' - ');
    } else if (rangeStr.includes('-')) {
      parts = rangeStr.split('-').map(p => p.trim());
    } else if (rangeStr.includes('to')) {
      parts = rangeStr.split('to').map(p => p.trim());
    } else {
      parts = [rangeStr, rangeStr];
    }
    
    if (parts.length < 2) {
      const today = new Date();
      const startOfWeek = new Date(today);
      startOfWeek.setDate(today.getDate() - today.getDay());
      return {
        start: startOfWeek,
        end: today
      };
    }
    
    let [startStr, endStr] = parts;
    const currentYear = new Date().getFullYear();
    
    // Parse start date (handle both / and _ separators)
    let startDate;
    const startDelimiter = startStr.includes('/') ? '/' : '_';
    if (startStr.includes(startDelimiter)) {
      const startParts = startStr.split(startDelimiter);
      const startMonth = parseInt(startParts[0], 10) - 1;
      const startDay = parseInt(startParts[1], 10);
      const startYear = startParts.length > 2 
                        ? (startParts[2].length === 2 ? 2000 + parseInt(startParts[2], 10) : parseInt(startParts[2], 10)) 
                        : currentYear;
      startDate = new Date(startYear, startMonth, startDay);
    } else {
      throw new Error(`Unrecognized start date: ${startStr}`);
    }
    
    // Parse end date (handle both / and _ separators)
    let endDate;
    const endDelimiter = endStr.includes('/') ? '/' : '_';
    if (endStr.includes(endDelimiter)) {
      const endParts = endStr.split(endDelimiter);
      const endMonth = parseInt(endParts[0], 10) - 1;
      const endDay = parseInt(endParts[1], 10);
      const endYear = endParts.length > 2 
                      ? (endParts[2].length === 2 ? 2000 + parseInt(endParts[2], 10) : parseInt(endParts[2], 10)) 
                      : currentYear;
      endDate = new Date(endYear, endMonth, endDay);
    } else {
      throw new Error(`Unrecognized end date: ${endStr}`);
    }
    
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      throw new Error(`Invalid date in range: ${rangeStr}`);
    }
    
    endDate.setHours(23, 59, 59, 999);
    
    if (startDate > endDate) {
      return { start: endDate, end: startDate };
    }
    
    return { start: startDate, end: endDate };
  } catch (error) {
    console.error(`Error parsing date range "${rangeStr}": ${error.message}`);
    const end = new Date();
    const start = new Date();
    start.setDate(start.getDate() - 7);
    return { start, end };
  }
}

/**
 * Hook function for payroll system integration
 */
function updateTechnicianKPI(techName) {
  if (!techName) {
    console.error("No technician name provided");
    return 0;
  }
  
  try {
    console.log(`Running KPI pull for ${techName}`);
    return pullTechnicianKPI(techName);
  } catch (error) {
    console.error(`Error in updateTechnicianKPI: ${error.message}`);
    return 0;
  }
}

// Runtime patch for Core/Main integration
(function() {
  try {
    var coreMain = Modules.Main || {};
    if (coreMain._techKpiPatched) return;

    var originalGetter = typeof _getOrderedModules === 'function' && _getOrderedModules;
    if (!originalGetter) return;

    globalThis._getOrderedModules = function() {
      var list = originalGetter();
      if (list.indexOf(Modules.TechKPI) === -1) {
        list.push(Modules.TechKPI);
      }
      return list;
    };
    coreMain._techKpiPatched = true;
  } catch (ignore) {}
})();