var Modules = Modules || {};
Modules.LeadSet = Modules.LeadSet || {};
Modules.LeadSet.Utilities = Modules.LeadSet.Utilities || {};

/**
 * Helper functions for the Lead Set module.
 */

/**
 * Finds the Lead Set sheet in the spreadsheet.
 * @param {SpreadsheetApp.Spreadsheet} ss - The spreadsheet to search in.
 * @return {SpreadsheetApp.Sheet} The Lead Set sheet or null if not found.
 */
function findLeadSetSheet(ss) {
  try {
    return ss.getSheetByName('Lead Set');
  } catch (error) {
    Logger.log('Error finding Lead Set sheet: ' + error.message);
    return null;
  }
}

/**
 * Gets lead data for a specific technician from the Lead Set sheet.
 * @param {SpreadsheetApp.Sheet} leadSetSheet - The Lead Set sheet.
 * @param {String} technicianName - The name of the technician.
 * @return {Array} Array of lead data objects for the technician.
 */
function getLeadDataForTechnician(leadSetSheet, technicianName) {
  const data = leadSetSheet.getDataRange().getValues();
  if (data.length === 0) return [];
  
  const headers = data[0];
  // Find column indices
  const indices = findLeadSetColumnIndices(headers);
  
  const technicianData = [];
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    if (row[indices.technician] === technicianName) {
      technicianData.push({
        customer: row[indices.customer],
        businessUnit: row[indices.businessUnit],
        completionDate: row[indices.completionDate],
        revenue: row[indices.revenue],
        notes: ''
      });
    }
  }
  
  return technicianData;
}

/**
 * Finds indices for important columns in the Lead Set sheet.
 * @param {Array} headerRow - The header row from the Lead Set sheet.
 * @return {Object} Object with column indices.
 */
function findLeadSetColumnIndices(headerRow) {
  // Initialize with default positions
  let indices = {
    invoiceId: 0,          // Column A - Invoice ID
    completionDate: 1,     // Column B - Completion Date
    customer: 2,           // Column C - Customer Name
    businessUnit: 3,       // Column D - Business Unit
    revenue: 4,            // Column E - Job Total Revenue
    balance: 5,            // Column F - Balance
    technician: 6,         // Column G - Lead Generated By
    soldBy: 7,             // Column H - Sold By
    assignedTechs: 8       // Column I - Assigned Technicians
  };
  
  // Try to find columns by header names
  for (let i = 0; i < headerRow.length; i++) {
    const header = headerRow[i] ? headerRow[i].toString().trim().toLowerCase() : '';
    
    if (header.includes('invoice') || header.includes('id')) {
      indices.invoiceId = i;
    } else if (header.includes('completion date') || header.includes('date')) {
      indices.completionDate = i;
    } else if (header.includes('customer')) {
      indices.customer = i;
    } else if (header.includes('business unit')) {
      indices.businessUnit = i;
    } else if (header.includes('revenue') || header.includes('total')) {
      indices.revenue = i;
    } else if (header.includes('balance')) {
      indices.balance = i;
    } else if (header.includes('lead generated') || header.includes('generated by')) {
      indices.technician = i;
    } else if (header.includes('sold by')) {
      indices.soldBy = i;
    } else if (header.includes('assigned')) {
      indices.assignedTechs = i;
    }
  }
  
  return indices;
}

/**
 * Gets all technician sheet names from the spreadsheet.
 * @param {SpreadsheetApp.Spreadsheet} ss - The spreadsheet to search in.
 * @return {Array} Array of technician sheet names.
 */
function getTechnicianSheets(ss) {
  const sheets = ss.getSheets();
  const technicianSheets = [];
  
  // Exclude known non-technician sheets
  const excludedSheets = [
    'Lead Set', 'Menu', 'PBP', 'Spiff/Bonus', 'Yard Signs', 'Timesheet',
    'Setup', 'Summary', 'Config', 'Instructions', 'Rates'
  ];
  
  for (let i = 0; i < sheets.length; i++) {
    const sheetName = sheets[i].getName();
    const isExcluded = excludedSheets.includes(sheetName) || 
                       sheetName.startsWith('_') || 
                       sheetName.includes('Sheet');
    
    if (!isExcluded) {
      technicianSheets.push(sheetName);
    }
  }
  
  return technicianSheets;
}

/**
 * Calculates commissions for lead data.
 * @param {Array} leadData - The lead data to process.
 * @return {Object} Object with processed leads and total commission.
 */
function calculateLeadCommissions(leadData) {
  let totalCommission = 0;
  const processedLeads = [];
  
  for (const lead of leadData) {
    // Convert revenue to number if it's not already
    const revenue = typeof lead.revenue === 'number' ? lead.revenue : parseFloat(lead.revenue);
    
    if (isNaN(revenue) || revenue <= 0) continue;
    
    // Calculate commission amount
    const calculation = calculateCommissionForRevenue(revenue);
    totalCommission += calculation.amount;
    
    // Create a note showing the tier and percentage applied
    let tier = '';
    if (revenue < 10000) {
      tier = '$1-$9,999 → 2%';
    } else if (revenue < 30000) {
      tier = '$10,000-$29,999 → 3%';
    } else {
      tier = '$30,000+ → 4%';
    }
    
    // Format the revenue for display
    const formattedRevenue = revenue.toLocaleString('en-US', {style: 'currency', currency: 'USD'});
    
    // Create the standardized note for Column I
    const note = `${calculation.percentage}% commission on ${formattedRevenue} (${tier})`;
    
    processedLeads.push({
      customer: lead.customer,
      businessUnit: lead.businessUnit,
      completionDate: lead.completionDate,
      amount: calculation.amount,
      notes: note,
      marker: 'L-E-A-D'
    });
  }
  
  return { processedLeads, totalCommission };
}

/**
 * Gets commission calculation for a revenue amount.
 * @param {Number} revenue - The revenue amount.
 * @return {Object} Object with calculated amount and percentage.
 */
function calculateCommissionForRevenue(revenue) {
  // Implement the tiered logic
  let percentage = 2; // Default to 2%
  
  if (revenue >= 10000 && revenue < 30000) {
    percentage = 3;
  } else if (revenue >= 30000) {
    percentage = 4;
  }
  
  const amount = revenue * (percentage / 100);
  return {
    amount: Math.round(amount * 100) / 100,
    percentage: percentage
  };
}

/**
 * Finds the first empty row in the technician's sheet after the headers.
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @return {Number} The row number of the first empty row.
 */
function findFirstEmptyRow(techSheet) {
  const headerRow = findCustomerNameHeaderRow(techSheet);
  const start = headerRow === -1 ? 7 : headerRow + 1;
  const lastRow = techSheet.getLastRow();
  
  if (lastRow < start) return start;
  
  const data = techSheet.getRange(start, 5, lastRow - start + 1, 6).getValues();
  for (let i = 0; i < data.length; i++) {
    if (data[i].every(c => c === '' || c === null)) return start + i;
  }
  
  return lastRow + 1;
}

/**
 * Finds the row with "Customer Name" in column E.
 * @param {SpreadsheetApp.Sheet} sheet - The sheet to search in.
 * @return {Number} The row number or -1 if not found.
 */
function findCustomerNameHeaderRow(sheet) {
  const rows = Math.min(50, sheet.getLastRow());
  const vals = sheet.getRange(1, 5, rows, 1).getValues();
  
  for (let i = 0; i < vals.length; i++) {
    if (vals[i][0] && vals[i][0].toString().trim().toLowerCase() === 'customer name') {
      return i + 1;
    }
  }
  
  return -1;
}

/**
 * Finds all rows with L-E-A-D markers in column J.
 * @param {SpreadsheetApp.Sheet} sheet - The sheet to search in.
 * @return {Number[]} Array of row numbers with L-E-A-D markers.
 */
function findExistingLeadSetRows(sheet) {
  const data = sheet.getDataRange().getValues();
  const rows = [];
  
  for (let i = 0; i < data.length; i++) {
    const val = data[i][9]; // Column J is index 9
    if (val && val.toString().includes('L-E-A-D')) {
      rows.push(i + 1); // 1-based row index
    }
  }
  
  return rows;
}

/**
 * Clears lead data in the Install section of the technician sheet.
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @return {Number} The number of rows cleared.
 */
function clearLeadDataInInstallSection(techSheet) {
  // Find existing lead rows
  const leadRows = findExistingLeadSetRows(techSheet);
  
  // Clear each lead row (columns E-J)
  leadRows.forEach(row => {
    techSheet.getRange(row, 5, 1, 6).clearContent();
  });
  
  return leadRows.length;
}

/**
 * Updates the lead summary information in the top section of the sheet.
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {Number} totalRevenue - The total revenue amount.
 * @param {Number} totalCommission - The total commission amount.
 */
function updateTopSummaryLeadSet(techSheet, totalRevenue, totalCommission) {
  try {
    // Look for lead summary row
    const data = techSheet.getRange('A1:A30').getValues();
    let row = -1;
    
    for (let i = 0; i < data.length; i++) {
      const val = data[i][0];
      if (val && typeof val === 'string') {
        const txt = val.toLowerCase();
        if (txt.includes('lead') && (txt.includes('total') || txt.includes('pay'))) {
          row = i + 1;
          break;
        }
      }
    }
    
    if (row > 0) {
      // Always use row 14 for Lead Set counts and totals
      techSheet.getRange(14, 2).setValue(totalRevenue).setNumberFormat('$#,##0.00');
      techSheet.getRange(14, 3).setValue(totalCommission).setNumberFormat('$#,##0.00');
    } else {
      // Fallback: also row 14 for both values
      techSheet.getRange(14, 2).setValue(totalRevenue).setNumberFormat('$#,##0.00');
      techSheet.getRange(14, 3).setValue(totalCommission).setNumberFormat('$#,##0.00');
    }
  } catch (error) {
    Logger.log(`Error updating lead summary: ${error.message}`);
  }
}

/**
 * Processes and writes lead data to the technician's sheet.
 * @param {SpreadsheetApp.Sheet} leadSetSheet - The Lead Set sheet.
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 * @param {String} technicianName - The name of the technician.
 * @param {Boolean} suppressPopup - Whether to suppress popup notifications.
 * @return {Object} Object containing processing results.
 */
function processAndWriteLeadData(leadSetSheet, techSheet, technicianName, suppressPopup = false) {
  // Extract and process leads
  const leads = getLeadDataForTechnician(leadSetSheet, technicianName);
  
  if (leads.length === 0) {
    return { 
      success: true, 
      leadsProcessed: 0, 
      totalCommission: 0,
      totalRevenue: 0
    };
  }
  
  // Calculate commissions and also total revenue
  const { processedLeads, totalCommission } = calculateLeadCommissions(leads);
  
  // Sum total revenue from leads data (column 'revenue')
  const totalRevenue = leads.reduce(function(sum, l) {
    var rev = l && typeof l.revenue === 'number' ? l.revenue : parseFloat(l.revenue || 0);
    return sum + (isNaN(rev) ? 0 : rev);
  }, 0);
  
  // Prepare data for writing
  const leadDataToWrite = processedLeads.map(lead => [
    lead.customer || '',              // Column E: Customer name
    lead.businessUnit || '',          // Column F: Business unit
    lead.completionDate || '',        // Column G: Completion date
    lead.amount || 0,                 // Column H: Commission amount
    lead.notes || 'Lead commission',  // Column I: Notes
    'L-E-A-D'                         // Column J: Lead identifier
  ]);
  
  // Find the insertion point
  const startRow = findFirstEmptyRow(techSheet);
  
  if (leadDataToWrite.length > 0) {
    // Write all lead data at once
    techSheet.getRange(startRow, 5, leadDataToWrite.length, 6).setValues(leadDataToWrite);
    
    // Format cells
    techSheet.getRange(startRow, 8, leadDataToWrite.length, 1).setNumberFormat('$#,##0.00'); // Column H - Amount
    techSheet.getRange(startRow, 7, leadDataToWrite.length, 1).setNumberFormat('mm/dd/yyyy'); // Column G - Date
  }
  
  // Update summary information with revenue and commission
  updateTopSummaryLeadSet(techSheet, totalRevenue, totalCommission);
  
  return {
    success: true,
    leadsProcessed: processedLeads.length,
    totalCommission: totalCommission,
    totalRevenue: totalRevenue
  };
}

/**
 * Handles "LEAD" entries in column J of technician sheets.
 * @param {SpreadsheetApp.Sheet} sheet - The sheet where the edit occurred.
 * @param {Number} row - The row number where the edit occurred.
 * @param {String} sheetName - The name of the sheet (technician name).
 */
function handleLeadEntryInColumnJ(sheet, row, sheetName) {
  try {
    // Validate inputs
    if (!sheet || !row || !sheetName) return;
    
    // Verify this is a technician sheet
    const nonTechSheets = ['Setup', 'Summary', 'Lead Set', 'Config', 'Instructions', 'Rates'];
    if (nonTechSheets.includes(sheetName) || sheetName.startsWith('_')) return;
    
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const leadSetSheet = findLeadSetSheet(ss);
    if (!leadSetSheet) return;
    
    // Get lead data for this technician
    const leadData = getLeadDataForTechnician(leadSetSheet, sheetName);
    if (!leadData || leadData.length === 0) return;
    
    // Find a matching lead item
    let leadItem = leadData[0]; // Default to first lead
    
    // Try to find a better match based on customer name
    const existingCustomer = sheet.getRange(row, 5).getValue();
    if (existingCustomer) {
      const matchingLead = leadData.find(lead => 
        lead.customer && lead.customer.toString().toLowerCase() === existingCustomer.toString().toLowerCase()
      );
      if (matchingLead) leadItem = matchingLead;
    }
    
    // Prepare values for the row
    const values = [
      leadItem.customer || '',                 // Column E - Customer name
      leadItem.businessUnit || '',             // Column F - Business unit
      leadItem.completionDate || '',           // Column G - Completion date
      0,                                       // Column H - Commission (placeholder)
      '',                                      // Column I - Notes (placeholder)
      'L-E-A-D'                                // Column J - Lead marker
    ];
    
    // Calculate commission if revenue is available
    if (leadItem.revenue) {
      const calculation = calculateCommissionForRevenue(leadItem.revenue);
      values[3] = calculation.amount; // Update commission amount
      
      // Create commission note
      let tier = '';
      if (leadItem.revenue < 10000) {
        tier = '$1-$9,999 → 2%';
      } else if (leadItem.revenue < 30000) {
        tier = '$10,000-$29,999 → 3%';
      } else {
        tier = '$30,000+ → 4%';
      }
      
      const formattedRevenue = leadItem.revenue.toLocaleString('en-US', {style: 'currency', currency: 'USD'});
      values[4] = `${calculation.percentage}% commission on ${formattedRevenue} (${tier})`;
      
      if (leadItem.notes && leadItem.notes.trim() !== '') {
        values[4] += ` - ${leadItem.notes.trim()}`;
      }
    }
    
    // Write values to the row
    sheet.getRange(row, 5, 1, 6).setValues([values]);
    
    // Format cells
    sheet.getRange(row, 8, 1, 1).setNumberFormat('$#,##0.00'); // Format commission as currency
    if (leadItem.completionDate instanceof Date) {
      sheet.getRange(row, 7, 1, 1).setNumberFormat('mm/dd/yyyy'); // Format date
    }
    
    // Update totals
    updateLeadTotalsAfterEdit(sheet);
  } catch (error) {
    Logger.log(`Error in handleLeadEntryInColumnJ: ${error.message}`);
  }
}

/**
 * Updates the lead totals after editing.
 * @param {SpreadsheetApp.Sheet} techSheet - The technician's sheet.
 */
function updateLeadTotalsAfterEdit(techSheet) {
  try {
    // Count all rows with "LEAD" in column J
    const data = techSheet.getDataRange().getValues();
    let leadCount = 0;
    let totalCommission = 0;
    
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      if (row[9] && row[9].toString().toUpperCase().includes('LEAD')) {
        leadCount++;
        // Add commission amount from column H (index 7)
        if (row[7] && typeof row[7] === 'number') {
          totalCommission += row[7];
        }
      }
    }
    
    // Update lead count in row 14, column B
    techSheet.getRange(14, 2).setValue(leadCount);
    
    // Update total commission in row 14, column C
    techSheet.getRange(14, 3).setValue(totalCommission);
    techSheet.getRange(14, 3).setNumberFormat('$#,##0.00');
  } catch (error) {
    Logger.log(`Error in updateLeadTotalsAfterEdit: ${error.message}`);
  }
}

/**
 * Gets required sheets for lead set processing.
 * @param {SpreadsheetApp.Spreadsheet} ss - The active spreadsheet.
 * @param {SpreadsheetApp.Sheet} leadSetSheet - The Lead Set sheet.
 * @param {String} technicianName - The name of the technician.
 * @return {Object} Object containing required sheets.
 */
function getRequiredSheets(ss, leadSetSheet, technicianName) {
  // Find the technician's sheet
  const techSheet = ss.getSheetByName(technicianName);
  if (!techSheet) {
    throw new Error(`Technician sheet not found for: ${technicianName}`);
  }
  
  // Find the Lead Set sheet if not provided
  let validLeadSetSheet = leadSetSheet;
  if (!validLeadSetSheet) {
    validLeadSetSheet = findLeadSetSheet(ss);
    if (!validLeadSetSheet) {
      throw new Error('Lead Set sheet not found');
    }
  }
  
  return { techSheet, validLeadSetSheet };
}

/**
 * Updates the status display for the user.
 * @param {String} message - The status message to display.
 */
function updateStatus(message) {
  SpreadsheetApp.getActiveSpreadsheet().toast(message, "Lead Set Status");
}

/**
 * Gets all technician names from the Lead Set sheet.
 * @param {SpreadsheetApp.Sheet} leadSetSheet - The Lead Set sheet.
 * @return {Array} Array of unique technician names.
 */
function getAllTechniciansFromLeadSet(leadSetSheet) {
  const data = leadSetSheet.getDataRange().getValues();
  if (data.length <= 1) return []; // Return empty array if only headers or empty
  
  const headers = data[0];
  const indices = findLeadSetColumnIndices(headers);
  
  // Get unique technician names
  const techNames = new Set();
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const techName = row[indices.technician];
    if (techName && typeof techName === 'string' && techName.trim() !== '') {
      techNames.add(techName.trim());
    }
  }
  
  return Array.from(techNames);
}

/**
 * Processes lead data for all technicians.
 * @param {SpreadsheetApp.Spreadsheet} ss - The active spreadsheet.
 * @param {SpreadsheetApp.Sheet} leadSetSheet - The Lead Set sheet.
 * @param {Array} technicianList - List of technician names to process.
 * @return {Object} Object containing count of technicians and leads processed.
 */
function processLeadDataForAllTechs(ss, leadSetSheet, technicianList) {
  // Get all technician names from the Lead Set sheet
  const leadsAllTechs = getAllTechniciansFromLeadSet(leadSetSheet);
  
  // Get all technician sheets
  const techSheets = getTechnicianSheets(ss);
  
  // If a technician list is provided, restrict techSheets accordingly
  let filteredTechSheets = techSheets;
  if (Array.isArray(technicianList) && technicianList.length > 0) {
    const filterSet = new Set(technicianList.map(function(n){return String(n).trim().toLowerCase();}));
    filteredTechSheets = techSheets.filter(function(name){ return filterSet.has(name.toLowerCase()); });
  }
  
  let results = {
    technicians: 0,
    leads: 0,
    errors: 0,
    totalCommission: 0,
    skipped: []
  };
  
  // Process technicians that have sheets
  for (const techName of filteredTechSheets) {
    updateStatus(`Processing ${techName}...`);
    
    // Call back to LeadSetMain for this function
    const techResult = Modules.LeadSet.Main.updateLeadSetForTechnician(ss, leadSetSheet, techName);
    
    if (techResult.success) {
      results.technicians++;
      results.leads += techResult.leadsProcessed || 0;
      results.totalCommission += techResult.totalCommission || 0;
    } else {
      results.errors++;
      Logger.log(`Error processing ${techName}: ${techResult.error || 'Unknown error'}`);
    }
  }
  
  // Identify technicians in the Lead Set sheet without their own sheet
  for (const techName of leadsAllTechs) {
    if (!filteredTechSheets.includes(techName)) {
      results.skipped.push(techName);
      Logger.log(`Skipped ${techName}: No sheet exists`);
    }
  }
  
  return results;
}

/**
 * Gets user confirmation before processing lead sets.
 * @param {SpreadsheetApp.Ui} ui - The UI instance.
 * @return {boolean} True if user confirmed, false otherwise.
 */
function getUserConfirmation(ui) {
  const response = ui.alert(
    'Process All Lead Sets',
    'This will process lead payments for all technicians. Continue?',
    ui.ButtonSet.YES_NO
  );
  return response === ui.Button.YES;
}

/**
 * Displays the results of lead set processing.
 * @param {SpreadsheetApp.Ui} ui - The UI instance.
 * @param {Object} result - The processing results.
 */
function displayProcessingResults(ui, result) {
  // Format skipped technicians list if any
  let skippedMessage = '';
  if (result.skipped && result.skipped.length > 0) {
    skippedMessage = `\n\n⚠️ Skipped ${result.skipped.length} technician(s) without sheets: ` + 
                     `${result.skipped.join(', ')}`;
  }

  ui.alert(
    'Lead Set Processing Complete',
    `Successfully processed ${result.technicians} technicians with ${result.leads} total leads.\n\n` +
    `Total commission: $${result.totalCommission.toFixed(2)}` +
    `${result.errors > 0 ? '\n\nErrors encountered: ' + result.errors : ''}` +
    `${skippedMessage}`,
    ui.ButtonSet.OK
  );
}

/**
 * Error handling wrapper for UI functions.
 * @param {Function} fn - The function to execute.
 * @param {String} context - The context of the operation for error reporting.
 */
function handleErrorsWithUI(fn, context) {
  try {
    return fn();
  } catch (error) {
    Logger.log(`Error in ${context}: ${error.message}`);
    SpreadsheetApp.getUi().alert(
      'Error',
      `An error occurred while ${context.toLowerCase()}: ${error.message}`,
      SpreadsheetApp.getUi().ButtonSet.OK
    );
    return null;
  }
}

// Attach all helper functions to namespace
Object.assign(Modules.LeadSet.Utilities, {
  findLeadSetSheet,
  getLeadDataForTechnician,
  findLeadSetColumnIndices,
  getTechnicianSheets,
  getAllTechniciansFromLeadSet,
  calculateLeadCommissions,
  calculateCommissionForRevenue,
  findFirstEmptyRow,
  findCustomerNameHeaderRow,
  findExistingLeadSetRows,
  clearLeadDataInInstallSection,
  updateTopSummaryLeadSet,
  processAndWriteLeadData,
  handleLeadEntryInColumnJ,
  updateLeadTotalsAfterEdit,
  getRequiredSheets,
  updateStatus,
  processLeadDataForAllTechs,
  getUserConfirmation,
  displayProcessingResults,
  handleErrorsWithUI
}); 