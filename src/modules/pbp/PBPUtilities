/**
* Cardinal Payroll System - PBP Utilities
* Contains utility and sheet operation functions for the PBP module.
* Includes functions merged from PBPSheetOperations.gs.
*/

// Namespace for PBP module
var Modules = Modules || {};
Modules.PBP = Modules.PBP || {};

/**
* Updates spiff/bonus for a specific technician with proper spacing management.
* This is the main function called when 'Spiff/Bonus' is selected in the Action column.
*
* @param {string} technicianName - The name of the technician to update
* @param {number} actionRow - The row in the Hourly + Spiff Pay sheet where the action was triggered
* @param {number} actionColumn - The column in the Hourly + Spiff Pay sheet where the action was triggered
*/
function updateSpiffBonusWithCustomersList(technicianName, actionRow, actionColumn) {
 var ui = SpreadsheetApp.getUi();
  try {
   // Core sheets
   var ss = SpreadsheetApp.getActiveSpreadsheet();
   var spiffBonusTab = ss.getSheetByName('Spiff/Bonus');
   var ratesSheet = ss.getSheetByName('Hourly + Spiff Pay');
   if (!spiffBonusTab) {
     ui.alert('Spiff/Bonus tab not found!');
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }

   // 1) Identify needed columns from Spiff/Bonus
   var bonusHeaderMap = getSpiffBonusHeaderMap(spiffBonusTab);
   
   // Log header mapping for debugging
   console.log("Using header mapping:", JSON.stringify(bonusHeaderMap));

   // Check if required headers exist (adjust required headers as needed)
   var requiredHeaders = ['customerName','jobBusinessUnit','completionDate','soldBy','bonusAmount','itemName'];
   var missingHeaders = [];
   for (var i = 0; i < requiredHeaders.length; i++) {
     var headerKey = requiredHeaders[i];
     // Check if the key exists and is not null/undefined
     if (!(headerKey in bonusHeaderMap) || bonusHeaderMap[headerKey] == null) {
       missingHeaders.push(headerKey);
     }
   }
   if (missingHeaders.length > 0) {
     ui.alert('Missing expected columns in Spiff/Bonus sheet: ' + missingHeaders.join(', '));
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }

   // 2) Collect spiff/bonus data for this technician
   var dataStartRow = 2; // Assume headers are in row 1
   if (spiffBonusTab.getLastRow() < dataStartRow) {
     ui.alert('No data found in the Spiff/Bonus sheet.');
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }
   var rowCount = spiffBonusTab.getLastRow() - dataStartRow + 1;
   var spiffDataRange = spiffBonusTab.getRange(dataStartRow, 1, rowCount, spiffBonusTab.getLastColumn());
   var spiffDataVals = spiffDataRange.getValues();
   if (!spiffDataVals || !spiffDataVals.length) {
     ui.alert('No data rows found in Spiff/Bonus sheet for processing.');
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }

   var totalSpiffAmount = 0;
   var customerData = [];
   var totalYardSpiffAmount = 0; // Initialize yard spiff total
   
   // Log all Cross Sale Group values found for debugging
   console.log(`Looking for Cross Sale Group values for technician ${technicianName} in column ${bonusHeaderMap.crossSaleGroup}`);
   
   // Parse and filter spiff rows
   for (var r = 0; r < spiffDataVals.length; r++) {
     var row = spiffDataVals[r];
     if (!row || row.every(function(cell) { return !cell; })) continue; // skip empty rows

     var soldBy = row[bonusHeaderMap.soldBy - 1] || "";
     // Skip if 'Sold By' doesn't match the technician
     if (soldBy !== technicianName) continue;
     
     var crossSaleGroup = bonusHeaderMap.crossSaleGroup ? (row[bonusHeaderMap.crossSaleGroup - 1] || "") : "";
     var custName = row[bonusHeaderMap.customerName - 1] || "";
     
     console.log(`Found row for ${technicianName}, customer "${custName}" with Cross Sale Group: "${crossSaleGroup}"`);

     // Extract data using the map, providing defaults
     var bonusAmountRaw = row[bonusHeaderMap.bonusAmount - 1];
     var actualBonusVal = bonusHeaderMap.actualBonusAmount ? row[bonusHeaderMap.actualBonusAmount - 1] : null; // Handle if actualBonusAmount wasn't found
     var busUnit = row[bonusHeaderMap.jobBusinessUnit - 1] || "";
     var dateVal = row[bonusHeaderMap.completionDate - 1] || "";
     var itemName = row[bonusHeaderMap.itemName - 1] || "";

     // Convert bonus to number (logic adapted from original)
     var bonusAmt = 0;
     if (typeof bonusAmountRaw === 'string' && bonusAmountRaw.includes('$')) {
       bonusAmt = parseFloat(bonusAmountRaw.replace(/[^0-9.-]+/g,''));
     } else if (bonusAmountRaw === true || bonusAmountRaw === 'true') {
       // Use actual bonus value if primary is 'true' or boolean true
       if (actualBonusVal !== null) {
         if (typeof actualBonusVal === 'string' && actualBonusVal.includes('$')) {
           bonusAmt = parseFloat(actualBonusVal.replace(/[^0-9.-]+/g,''));
         } else {
           bonusAmt = parseFloat(actualBonusVal || 0);
         }
       } else {
         console.log("Warning: Bonus amount was 'true' but no 'Actual Bonus Amount' column found or mapped for row " + (r + dataStartRow));
         bonusAmt = 0; // Set to 0 if 'true' but no backup column value
       }
     } else {
       bonusAmt = parseFloat(bonusAmountRaw || 0);
     }

     // If a valid bonus amount was calculated, add to totals and data
     if (!isNaN(bonusAmt) && bonusAmt > 0) {
       totalSpiffAmount += bonusAmt;
       customerData.push({
         customerName: custName,
         jobBusinessUnit: busUnit,
         completionDate: dateVal,
         commission: bonusAmt,
         itemName: itemName
       });

       // Check if it's a Yard Spiff
       if (crossSaleGroup && typeof crossSaleGroup === 'string' && crossSaleGroup.toUpperCase().includes("YARD")) {
         console.log(`Found YARD in Cross Sale Group: "${crossSaleGroup}" for customer: ${custName}`);
         
         // Extract the numeric value from the YARD string (e.g., "YARD25" should give 25)
         var yardMatch = crossSaleGroup.toUpperCase().match(/YARD(\d+)/);
         console.log(`Regex match result for "${crossSaleGroup}": ${yardMatch ? JSON.stringify(yardMatch[0] + " -> " + yardMatch[1]) : "no match"}`);
         
         if (yardMatch && yardMatch[1]) {
           // If we found a number after "YARD", use that as the yard amount
           var yardAmount = parseFloat(yardMatch[1]);
           console.log(`Extracted yard amount: ${yardAmount} from "${crossSaleGroup}"`);
           
           if (!isNaN(yardAmount)) {
             totalYardSpiffAmount += yardAmount;
             console.log(`Added ${yardAmount} to yard total, new total: ${totalYardSpiffAmount}`);
           } else {
             // Fallback to the full bonus amount if we couldn't parse a number
             totalYardSpiffAmount += bonusAmt;
             console.log(`Failed to parse yard amount, using full bonus amount: ${bonusAmt}`);
           }
         } else {
           // If there's no number after "YARD", use the full bonus amount
           totalYardSpiffAmount += bonusAmt;
           console.log(`No number found after YARD, using full bonus amount: ${bonusAmt}`);
         }
       }
     }
   }

   // 3) Get Technician sheet
   var techSheet = ss.getSheetByName(technicianName);
   if (!techSheet) {
     ui.alert('No sheet found for technician: ' + technicianName);
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }

   // 4) Update top summary spiffs in the tech sheet
   updateTopSummarySpiffs(techSheet, totalSpiffAmount, totalYardSpiffAmount);

   // 5) Find relevant sections in the tech sheet
   var spiffSectionRow = findSpiffCustomerDataSection(techSheet);
   if (spiffSectionRow <= 0) {
     ui.alert("Error: Could not find Spiff data section header in " + technicianName + "'s sheet.");
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }
   var spiffHeaderRow = spiffSectionRow + 1; // Row containing column titles like "Customer Name", "Amount" etc.
   var spiffDataStartRow = spiffHeaderRow + 1; // First row where actual spiff data goes

   // Find the start of the next major section (e.g., "Install") to determine available space
   var nextSectionRow = findNextSectionStart(techSheet, spiffDataStartRow); // Helper to find the next non-empty row in Col A
   if (nextSectionRow <= 0) {
     ui.alert("Error: Could not determine the end of the Spiff section in " + technicianName + "'s sheet. Could not find next section header.");
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }
   console.log(`Spiff Header at ${spiffHeaderRow}, Data starts ${spiffDataStartRow}, Next Section at ${nextSectionRow}`);


   // 6) Clear existing Spiff data and formatting
   clearSpiffDataSection(techSheet);
   // After clearing, the nextSectionRow might have changed due to row deletion within clearSpiffDataSection.
   // Recalculate the available rows based on the single 'Total' row left by the clear function.
   // The 'Total' row is at spiffDataStartRow after clearing.
   var currentDataRows = 1; // Starts with just the 'Total' row.

   // 7) Manage rows in the spiff data section (adjust based on the cleared state)
   // Rows needed: customer entries + 1 for the total row
   var rowsNeeded = customerData.length + 1;
   console.log(`After clear: Current rows available (just Total row): ${currentDataRows}, Rows needed (data + Total): ${rowsNeeded}`);

   manageSheetRows(techSheet, spiffDataStartRow, currentDataRows, rowsNeeded);

   // 8) Write Spiff Data to Tech Sheet (Starts at spiffDataStartRow)
   writeSpiffDataToSheet(techSheet, spiffHeaderRow, customerData);

   // 9) Add/Update Total Row (This will overwrite the placeholder total row if data exists)
   addSpiffTotalRow(techSheet, spiffHeaderRow, customerData.length);

   // 10) Mark as done in 'Hourly + Spiff Pay' sheet
   if (ratesSheet && actionRow && actionColumn) {
      ratesSheet.getRange(actionRow, actionColumn).setValue("Complete");
   }

   ui.alert(
     'SPIFF bonus updated for ' + technicianName + '.\n' +
     'Total SPIFF: $' + totalSpiffAmount.toFixed(2) + ' (' + customerData.length + ' entries)\n' +
     'Yard Sign Spiff: $' + totalYardSpiffAmount.toFixed(2)
   );

 } catch(err) {
   console.error("Error in updateSpiffBonusWithCustomersList for " + technicianName + ": " + err.message + "\nStack: " + err.stack);
   ui.alert('Error processing Spiff/Bonus for ' + technicianName + ': ' + err.message);
   // Attempt to reset dropdown on error
   if (ratesSheet && actionRow && actionColumn) {
     try {
       resetActionDropdown(ratesSheet, actionRow, actionColumn);
     } catch (resetErr) {
       console.error("Failed to reset action dropdown: " + resetErr.message);
     }
   }
 }
}

/**
* Processes Spiff/Bonus for all technicians
* Ignores action column status completely
* No approval required
*/
function processAllSpiffBonusWithCustomers() {
 var ui = SpreadsheetApp.getUi();
 var ss = SpreadsheetApp.getActiveSpreadsheet();
 var ratesSheet = ss.getSheetByName('Hourly + Spiff Pay');
 if (!ratesSheet) {
   ui.alert('Hourly + Spiff Pay sheet not found!');
   return;
 }

 var ratesMapping = getRatesSheetMapping(); // Use utility function
 var ratesData = ratesSheet.getDataRange().getValues();
 var techsToProcess = [];

 // Get all sheets in the spreadsheet to check for existence
 var allSheets = ss.getSheets();
 var sheetNames = allSheets.map(function(sheet) {
   return sheet.getName();
 });

 // Gather all technicians regardless of status
 for (var i = ratesMapping.dataStartRow - 1; i < ratesData.length; i++) { // Adjust index for 0-based array
   var row = ratesData[i];
   var techName = row[ratesMapping.nameColumn - 1];

   // Ensure techName is valid and sheet exists
   if (techName && typeof techName === 'string' && techName.trim() !== "" && sheetNames.indexOf(techName) !== -1) {
     techsToProcess.push({
       name: techName,
       row: i + 1, // 1-based row index
       col: ratesMapping.actionColumn
     });
   }
 }

 if (techsToProcess.length === 0) {
   ui.alert('No technicians with sheets found for Spiff/Bonus processing.');
   return;
 }

 // Process each technician - no approval needed
 var errors = [];
 var successCount = 0;
 var processedTechs = [];
 var totalAmount = 0;
 
 for (var t = 0; t < techsToProcess.length; t++) {
   var tech = techsToProcess[t];
   try {
     console.log("Processing Spiff/Bonus for: " + tech.name + " (Row: " + tech.row + ")");
     var result = updateSpiffBonusWithCustomersListAll(tech.name);
     successCount++;
     
     // Store details for this technician
     if (result && result.amount > 0) {
       processedTechs.push({
         name: tech.name,
         count: result.count || 0,
         amount: result.amount || 0
       });
       totalAmount += result.amount;
     }
   } catch (error) {
     console.error("Failed processing Spiff/Bonus for " + tech.name + ": " + error.message);
     errors.push(tech.name + ": " + error.message);
   }
 }

 // Build pretty summary message like the screenshot
 var summaryMessage = [];
 summaryMessage.push("SPIFF/BONUS PROCESSING COMPLETE");
 
 // Add summary section
 summaryMessage.push("\nSUMMARY:");
 summaryMessage.push("• Total Technicians Processed: " + successCount);
 summaryMessage.push("• Total Amount: $" + totalAmount.toFixed(2));
 
 // Add technician details section
 if (processedTechs.length > 0) {
   summaryMessage.push("\nDETAILS BY TECHNICIAN:");
   
   for (var i = 0; i < processedTechs.length; i++) {
     var techInfo = processedTechs[i];
     summaryMessage.push("\n" + techInfo.name + ":");
     summaryMessage.push("• Entries: " + techInfo.count);
     summaryMessage.push("• Amount: $" + techInfo.amount.toFixed(2));
   }
 }
 
 // Add errors section if we have any
 if (errors.length > 0) {
   summaryMessage.push("\nERRORS:");
   for (var j = 0; j < errors.length; j++) {
     summaryMessage.push("• " + errors[j]);
   }
 }
 
 // Show the popup
 ui.alert(summaryMessage.join("\n"));
}

/**
* Modified version of updateSpiffBonusWithCustomersList that returns results
* @param {string} technicianName - The technician's name
* @return {object} Result object with count and amount
*/
function updateSpiffBonusWithCustomersListAll(technicianName) {
  try {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var techSheet = ss.getSheetByName(technicianName);
    
    if (!techSheet) {
      throw new Error("Technician sheet not found");
    }
    
    var spiffBonusSheet = ss.getSheetByName('Spiff/Bonus');
    if (!spiffBonusSheet) {
      throw new Error("Spiff/Bonus sheet not found");
    }
    
    // Process the spiff/bonus data
    var result = processSpiffAndBonusData(techSheet, technicianName, spiffBonusSheet);
    
    return {
      count: result.entryCount || 0,
      amount: result.totalAmount || 0
    };
  } catch (error) {
    console.error("Error in updateSpiffBonusWithCustomersListAll: " + error.message);
    throw error;
  }
}

/**
* Adds or updates the total row at the end of spiff data section.
* @param {Sheet} sheet - The technician's sheet.
* @param {number} headerRow - The row containing the column headers for the spiff section.
* @param {number} dataCount - The number of spiff data entries (not counting the total row).
*/
function addSpiffTotalRow(sheet, headerRow, dataCount) {
  if (!sheet || !headerRow) {
    console.error("addSpiffTotalRow: Missing required parameters");
    return;
  }
  
  try {
    // Get the headers to find the correct columns
    var headerRange = sheet.getRange(headerRow, 1, 1, 10); // Get up to 10 columns
    var headers = headerRange.getValues()[0];
    
    // Find column indices for Customer Name, Amount, and Type
    var customerCol = -1;
    var amountCol = -1;
    var typeCol = -1;
    
    for (var i = 0; i < headers.length; i++) {
      var header = headers[i].toString().toLowerCase();
      if (header.includes("customer")) {
        customerCol = i + 1; // 1-based column index
      } else if (header.includes("amount") || header.includes("commission")) {
        amountCol = i + 1;
      } else if (header.includes("type")) {
        typeCol = i + 1;
      }
    }
    
    // Verify we found the necessary columns
    if (customerCol === -1 || amountCol === -1) {
      console.error("addSpiffTotalRow: Could not find required columns");
      return;
    }
    
    // Calculate the row for the total based on header row and data count
    var totalRow = headerRow + dataCount + 1;
    
    // Set "Total" in the customer column
    sheet.getRange(totalRow, customerCol).setValue("Total");
    
    // Calculate sum of amount column
    if (dataCount > 0 && amountCol > 0) {
      var dataStartRow = headerRow + 1;
      var formula = "=SUM(" + 
                   sheet.getRange(dataStartRow, amountCol, dataCount, 1).getA1Notation() + 
                   ")";
      sheet.getRange(totalRow, amountCol).setFormula(formula);
    } else {
      // If no data, set total to 0
      sheet.getRange(totalRow, amountCol).setValue(0);
    }
    
    // Set "Total" in the type column if it exists
    if (typeCol > 0) {
      sheet.getRange(totalRow, typeCol).setValue("Total");
    }
    
    // Apply formatting
    var totalRange = sheet.getRange(totalRow, 1, 1, headers.length);
    totalRange.setFontWeight("bold");
    if (amountCol > 0) {
      sheet.getRange(totalRow, amountCol).setNumberFormat("$#,##0.00");
    }
    
    console.log("Added Spiff Total row at row " + totalRow);
  } catch (e) {
    console.error("Error in addSpiffTotalRow: " + e.message);
  }
}

/**
 * --- SHEET OPERATIONS FUNCTIONS ---
 */

/**
* Writes the calculated PBP data to the technician's sheet.
* @param {Sheet} techSheet - The specific technician's sheet object.
* @param {Array<object>} allPbpEntries - Array of calculated PBP entry objects.
* @param {number} totalTechnicianShare - The total calculated PBP share for the tech.
*/
Modules.PBP.writePbpDataToSheet = function(techSheet, allPbpEntries, totalTechnicianShare) {
  if (!techSheet || !allPbpEntries) {
    console.error("writePbpDataToSheet: Invalid arguments.");
    return;
  }

  // --- 1. Update Top Summary ---
  Modules.PBP.updateTopSummaryInstallPay(techSheet, totalTechnicianShare, allPbpEntries.length);

  // --- 2. Find existing PBP rows in column J ---
  var lastRow = techSheet.getLastRow();
  var existingPbpRows = findExistingPbpRows(techSheet);
  
  // --- 3. Prepare data for writing ---
  var tz = Session.getScriptTimeZone() || 'America/New_York';
  var dataToWrite = [];
  
  for (var idx = 0; idx < allPbpEntries.length; idx++) {
    var entry = allPbpEntries[idx];
    // Use internal fallback function instead of relying on Modules.Shared.DateUtils
    var dateObj = parseDateSafe(entry.completionDate);
    var displayDate = dateObj ? Utilities.formatDate(dateObj, tz, "MM/dd/yyyy") : (entry.completionDate || "");
    
    // Build notes column
    var notesParts = [];
    // Start with the tech's role and percentage for this job
    notesParts.push(`${entry.roleForJob} (${entry.splitPercentage.toFixed(1)}%)`);

    // Add the detailed team breakdown if available
    if (entry.teamDetails) {
      // Team details will be included regardless of whether it's a solo job or not
      notesParts.push(`Team: ${entry.teamDetails}`);
    }

    // Append the job's total PBP amount for full context
    var notesText = notesParts.join(' - ') + ` | Job PBP: $${entry.totalPbp.toFixed(2)}`;

    // --- New Column F content combining Business Unit & Item ---
    var colFText;
    if (entry.jobBusinessUnit && entry.itemName) {
      colFText = `${entry.jobBusinessUnit} / Item: ${entry.itemName}`;
    } else if (entry.jobBusinessUnit) {
      colFText = entry.jobBusinessUnit;
    } else if (entry.itemName) {
      colFText = `Item: ${entry.itemName}`;
    } else {
      colFText = "";
    }

    dataToWrite.push([
      entry.customerName || "",      // Column E: Customer Name
      colFText,                       // Column F: Combined info
      displayDate,                   // Column G: Completion Date
      entry.technicianShare,         // Column H: Commission Amount
      notesText,                     // Column I: Notes
      "PBP"                          // Column J: Type
    ]);
  }
  
  // --- 4. Write data to the sheet ---
  if (dataToWrite.length === 0) {
    console.log("No PBP data to write");
    return;
  }
  
  // If we have existing PBP rows, update them
  if (existingPbpRows.length > 0) {
    console.log("Found " + existingPbpRows.length + " existing PBP rows to update");
    
    // The number of rows we need to update
    var rowsToUpdate = Math.min(existingPbpRows.length, dataToWrite.length);
    
    // Update existing rows first
    for (var i = 0; i < rowsToUpdate; i++) {
      var targetRow = existingPbpRows[i];
      var targetRange = techSheet.getRange(targetRow, 5, 1, 6); // Columns E-J (5-10)
      targetRange.setValues([dataToWrite[i]]);
    }
    
    // If we have more entries than existing PBP rows, look for empty rows
    if (dataToWrite.length > existingPbpRows.length) {
      var remainingEntries = dataToWrite.slice(existingPbpRows.length);
      writeRemainingPbpEntries(techSheet, remainingEntries);
    }
    
    // If we have fewer entries than existing PBP rows, clear the excess rows
    if (existingPbpRows.length > dataToWrite.length) {
      console.log("Clearing " + (existingPbpRows.length - dataToWrite.length) + " excess PBP rows");
      for (var j = dataToWrite.length; j < existingPbpRows.length; j++) {
        var excessRow = existingPbpRows[j];
        // Only delete data in columns E-J (5-10) where column J contains "PBP"
        // These rows come from findExistingPbpRows, which guarantees column J contains "PBP"
        techSheet.getRange(excessRow, 5, 1, 6).clearContent();
      }
    }
  } else {
    // No existing PBP rows, write all entries to empty rows
    writeRemainingPbpEntries(techSheet, dataToWrite);
  }
  
  console.log("Sheet update finished for: " + techSheet.getName());
};

/**
 * Finds all rows that have "PBP" in column J
 * @param {Sheet} sheet - The technician sheet to search
 * @return {Array} Array of row numbers that have "PBP" in column J
 */
function findExistingPbpRows(sheet) {
  var lastRow = sheet.getLastRow();
  var typeColumn = 10; // Column J
  var rows = [];
  
  // Skip if sheet doesn't have enough columns
  if (sheet.getLastColumn() < typeColumn) {
    return rows;
  }
  
  // Get all values in column J
  var typeValues = sheet.getRange(1, typeColumn, lastRow, 1).getValues();
  
  // Find rows with "PBP" in column J - ONLY these rows will ever be cleared
  for (var i = 0; i < typeValues.length; i++) {
    var cellValue = typeValues[i][0];
    if (cellValue && typeof cellValue === 'string' && 
        cellValue.toString().trim().toLowerCase() === "pbp") {
      rows.push(i + 1); // Convert to 1-based row index
    }
  }
  
  console.log("Found " + rows.length + " rows with PBP in type column");
  return rows;
}

/**
 * Writes PBP entries to empty rows in columns E-J
 * @param {Sheet} sheet - The technician sheet
 * @param {Array} entries - The PBP entries to write
 */
function writeRemainingPbpEntries(sheet, entries) {
  if (!entries || entries.length === 0) return;
  
  // Find the header row with "Customer Name" in column E
  var headerRow = findCustomerNameHeaderRow(sheet);
  if (headerRow <= 0) {
    console.log("Could not find 'Customer Name' header in column E in " + sheet.getName());
    return;
  }
  
  // Start looking at the row after the header
  var firstDataRow = headerRow + 1;
  var lastRow = sheet.getLastRow();
  
  // Find first empty row in columns E-J
  var startRow = -1;
  var rowsToSearch = Math.min(50, lastRow - firstDataRow + 1); // Cap at 50 rows
  
  if (rowsToSearch > 0) {
    var rowData = sheet.getRange(firstDataRow, 5, rowsToSearch, 6).getValues(); // Columns E-J (5-10)
    
    for (var i = 0; i < rowData.length; i++) {
      var isEmpty = true;
      for (var j = 0; j < rowData[i].length; j++) {
        if (rowData[i][j] !== "") {
          isEmpty = false;
          break;
        }
      }
      
      if (isEmpty) {
        startRow = firstDataRow + i;
        break;
      }
    }
  }
  
  // If we couldn't find an empty row, use the first data row
  if (startRow === -1) {
    startRow = firstDataRow;
    console.log("No empty rows found, using first row after header: " + startRow);
  }
  
  console.log("Writing " + entries.length + " entries starting at row " + startRow);
  
  // Write each entry
  for (var k = 0; k < entries.length; k++) {
    var currentRow = startRow + k;
    var targetRange = sheet.getRange(currentRow, 5, 1, 6); // Columns E-J (5-10)
    targetRange.setValues([entries[k]]);
    
    // Apply formatting
    sheet.getRange(currentRow, 7, 1, 1).setNumberFormat('MM/dd/yyyy'); // Date column format
    sheet.getRange(currentRow, 8, 1, 1).setNumberFormat('$#,##0.00'); // Commission column format
  }
}

/**
 * Finds the row that contains "Customer Name" in column E
 * @param {Sheet} sheet - The technician sheet
 * @return {number} The row number (1-based) or -1 if not found
 */
function findCustomerNameHeaderRow(sheet) {
  var lastRow = Math.min(50, sheet.getLastRow()); // Check first 50 rows
  var columnE = sheet.getRange(1, 5, lastRow, 1).getValues();
  
  for (var i = 0; i < columnE.length; i++) {
    var cellValue = columnE[i][0];
    if (cellValue && typeof cellValue === 'string' &&
        cellValue.toString().trim().toLowerCase() === "customer name") {
      return i + 1; // Convert to 1-based row index
    }
  }
  
  return -1; // Not found
}

/**
* Updates the top summary section ('Total Install Pay') with amount and count.
* @param {Sheet} sheet - The technician sheet to update.
* @param {number} amount - The total PBP amount.
* @param {number} count - The number of PBP entries.
*/
Modules.PBP.updateTopSummaryInstallPay = function(sheet, amount, count) {
  if (!sheet) return;
  // Target row 13 specifically for Total Install Pay based on screenshot
  var installPayRow = 13;
  try {
     sheet.getRange(installPayRow, 2).setValue(count); // Count in Col B (B13)
     sheet.getRange(installPayRow, 3).setValue(amount).setNumberFormat("$#,##0.00"); // Amount in Col C (C13)
     console.log("Updated Total Install Pay in B13/C13 with count: " + count + ", amount: $" + amount.toFixed(2));
  } catch (e) { 
     console.error("Error updating top summary install pay for " + sheet.getName() + ": " + e); 
     
     // Fallback to searching for "Total Install Pay" if row 13 doesn't work
     var data = sheet.getRange("A1:A20").getValues(); // Check first 20 rows
     for (var row = 0; row < data.length; row++) {
       if (data[row][0] && data[row][0].toString().trim() === "Total Install Pay") {
         installPayRow = row + 1;
         try {
           sheet.getRange(installPayRow, 2).setValue(count); // Count in Col B
           sheet.getRange(installPayRow, 3).setValue(amount).setNumberFormat("$#,##0.00"); // Amount in Col C
           console.log("Fallback: Updated Total Install Pay in row " + installPayRow);
         } catch (err) { 
           console.error("Fallback also failed to update top summary: " + err); 
         }
         break;
       }
     }
  }
};

/**
* Finds the row where the Install Customer Data section starts.
* @param {Sheet} sheet - The sheet to search in.
* @return {number} The row number (1-based) or -1 if not found.
*/
function findInstallCustomerDataSection(sheet) {
  if (!sheet) return -1;
  var data = sheet.getRange("A1:A50").getValues(); // Search first 50 rows
  for (var i = 0; i < data.length; i++) {
    var value = data[i][0];
    if (value && typeof value === "string") {
      var trimmedValue = value.trim();
      if (trimmedValue === "Install [Customer Data]" || trimmedValue === "Install Customer Data" || trimmedValue === "Install & Sales") { return i + 1; }
    }
  }
  // Fallback search (case-insensitive, partial, below row 15)
  for (var i = 0; i < data.length; i++) { // Start from the beginning instead of row 15
     var value = data[i][0];
     if (value && typeof value === "string") {
       var lowerValue = value.toLowerCase().trim();
       if (lowerValue.includes("install") && (lowerValue.includes("customer") || lowerValue.includes("data") || lowerValue.includes("sales") || lowerValue.includes("&"))) {
         console.log("Found install section using partial match: '" + value + "' at row " + (i+1));
         return i + 1;
       }
     }
  }
  console.log("No Install section header found in sheet: " + sheet.getName());
  return -1;
}

/**
* Finds the row where the next section after Install starts.
* @param {Sheet} sheet - The sheet to search in.
* @param {number} installSectionRow - The row where the Install section starts.
* @return {number} The row number (1-based) or -1 if not found.
*/
function findNextSectionAfterInstall(sheet, installSectionRow) {
  if (!sheet || installSectionRow <= 0) return -1;
  var startSearchRow = installSectionRow + 3; // Start looking below header/first data
  var maxSearchRow = Math.min(sheet.getLastRow() + 1, installSectionRow + 60); // Search ample rows
  if (startSearchRow >= maxSearchRow) return -1;


  var searchValues = sheet.getRange(startSearchRow, 1, maxSearchRow - startSearchRow, 1).getValues();
  for (var i = 0; i < searchValues.length; i++) {
    var rowValue = searchValues[i][0];
    var actualRow = startSearchRow + i;
    if (rowValue && typeof rowValue === "string") {
      var trimmedValue = rowValue.trim();
      var lowerValue = trimmedValue.toLowerCase();
      // Look for non-empty cells that don't seem like data continuation or total rows
      if (trimmedValue.length > 0 && !lowerValue.includes("install") && !lowerValue.includes("total")) {
         // Simple check: If it contains common section words or ends with 'Data]'?
        if (lowerValue.includes("data") || lowerValue.includes("sales") || lowerValue.includes("spiff") || lowerValue.includes("bonus") || lowerValue.includes("lead") || lowerValue.includes("customer") || trimmedValue.endsWith("Data]")) {
           console.log("Found next section header '" + trimmedValue + "' at row " + actualRow);
           return actualRow;
        }
      }
    }
  }
  console.log("No next section found after Install section in sheet: " + sheet.getName());
  return -1;
}

/**
* Clears the data rows in the Install section where Type column (J) contains 'PBP'.
* Only clears columns E-J (5-10), preserving columns A-D.
*
* @param {Sheet} sheet - The technician sheet to clear.
* @return {number} The number of rows cleared
*/
Modules.PBP.clearInstallDataSection = function(sheet) {
  if (!sheet) return 0;
  try {
    // First, find the Install section
    var installSectionRow = findInstallCustomerDataSection(sheet);
    if (installSectionRow <= 0) {
      console.log("Clear Install Data: Install section not found in " + sheet.getName());
      return 0;
    }
    
    var dataStartRow = installSectionRow + 1;
    var nextSectionRow = findNextSectionAfterInstall(sheet, installSectionRow);
    
    if (nextSectionRow <= 0) {
      nextSectionRow = sheet.getLastRow() + 1;
      console.log("No next section found, using last row + 1 (" + nextSectionRow + ") as boundary");
    }

    var rowsAvailable = nextSectionRow - dataStartRow;
    if (rowsAvailable <= 0) {
      console.log("No data rows available to clear in " + sheet.getName());
      return 0;
    }
    
    // Find existing PBP rows
    var pbpRows = findExistingPbpRows(sheet);
    
    // ONLY clear the CELLS in columns E-J where Type column (J) contains 'PBP'
    var rowsCleared = 0;
    for (var i = 0; i < pbpRows.length; i++) {
      var rowToClear = pbpRows[i];
      // Only clear row if it's in the Install section range
      if (rowToClear >= dataStartRow && rowToClear < nextSectionRow) {
        sheet.getRange(rowToClear, 5, 1, 6).clearContent(); // Clear ONLY columns E-J (5-10)
        rowsCleared++;
      }
    }
    
    console.log("Cleared " + rowsCleared + " rows with Type='PBP' in " + sheet.getName());
    return rowsCleared;
  } catch (e) {
    console.error("Error clearing install data section: " + e.message);
    return 0;
  }
};

/**
 * Local fallback date parsing function in case Modules.Shared.DateUtils is not available
 * Attempts to convert a value to a Date object
 * 
 * @param {*} value - The value to parse as a date
 * @return {Date|null} A Date object or null if parsing fails
 */
function parseDateSafe(value) {
  if (value instanceof Date) return value;
  
  if (typeof value === 'number') {
    // Google Sheets often stores dates as serial numbers (days since Dec 30, 1899)
    return new Date(Math.round((value - 25569) * 86400000));
  }
  
  if (typeof value === 'string') {
    var parsed = new Date(value);
    if (!isNaN(parsed.getTime())) return parsed;
  }
  
  return null;
} 