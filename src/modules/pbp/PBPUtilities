/**
* Cardinal Payroll System - PBP Utilities
* Contains utility and sheet operation functions for the PBP module.
* Includes functions merged from PBPSheetOperations.gs.
*/

// Namespace for PBP module
var Modules = Modules || {};
Modules.PBP = Modules.PBP || {};

/**
* Updates spiff/bonus for a specific technician with proper spacing management.
* This is the main function called when 'Spiff/Bonus' is selected in the Action column.
*
* @param {string} technicianName - The name of the technician to update
* @param {number} actionRow - The row in the Main sheet where the action was triggered
* @param {number} actionColumn - The column in the Main sheet where the action was triggered
*/
function updateSpiffBonusWithCustomersList(technicianName, actionRow, actionColumn) {
 var ui = SpreadsheetApp.getUi();
  try {
   // Core sheets
   var ss = SpreadsheetApp.getActiveSpreadsheet();
   var spiffBonusTab = ss.getSheetByName('Spiff/Bonus');
   var ratesSheet = ss.getSheetByName(Modules.Constants.SHEET.MAIN);
   if (!spiffBonusTab) {
     ui.alert('Spiff/Bonus tab not found!');
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }

   // 1) Identify needed columns from Spiff/Bonus
   var bonusHeaderMap = getSpiffBonusHeaderMap(spiffBonusTab);
   
   // Log header mapping for debugging
   console.log("Using header mapping:", JSON.stringify(bonusHeaderMap));

   // Check if required headers exist (adjust required headers as needed)
   var requiredHeaders = ['customerName','jobBusinessUnit','completionDate','soldBy','bonusAmount','itemName'];
   var missingHeaders = [];
   for (var i = 0; i < requiredHeaders.length; i++) {
     var headerKey = requiredHeaders[i];
     // Check if the key exists and is not null/undefined
     if (!(headerKey in bonusHeaderMap) || bonusHeaderMap[headerKey] == null) {
       missingHeaders.push(headerKey);
     }
   }
   if (missingHeaders.length > 0) {
     ui.alert('Missing expected columns in Spiff/Bonus sheet: ' + missingHeaders.join(', '));
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }

   // 2) Collect spiff/bonus data for this technician
   var dataStartRow = 2; // Assume headers are in row 1
   if (spiffBonusTab.getLastRow() < dataStartRow) {
     ui.alert('No data found in the Spiff/Bonus sheet.');
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }
   var rowCount = spiffBonusTab.getLastRow() - dataStartRow + 1;
   var spiffDataRange = spiffBonusTab.getRange(dataStartRow, 1, rowCount, spiffBonusTab.getLastColumn());
   var spiffDataVals = spiffDataRange.getValues();
   if (!spiffDataVals || !spiffDataVals.length) {
     ui.alert('No data rows found in Spiff/Bonus sheet for processing.');
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }

   var totalSpiffAmount = 0;
   var customerData = [];
   var totalYardSpiffAmount = 0; // Initialize yard spiff total
   
   // Log all Cross Sale Group values found for debugging
   console.log(`Looking for Cross Sale Group values for technician ${technicianName} in column ${bonusHeaderMap.crossSaleGroup}`);
   
   // Parse and filter spiff rows
   for (var r = 0; r < spiffDataVals.length; r++) {
     var row = spiffDataVals[r];
     if (!row || row.every(function(cell) { return !cell; })) continue; // skip empty rows

     var soldBy = row[bonusHeaderMap.soldBy - 1] || "";
     // Skip if 'Sold By' doesn't match the technician
     if (soldBy !== technicianName) continue;
     
     var crossSaleGroup = bonusHeaderMap.crossSaleGroup ? (row[bonusHeaderMap.crossSaleGroup - 1] || "") : "";
     var custName = row[bonusHeaderMap.customerName - 1] || "";
     
     console.log(`Found row for ${technicianName}, customer "${custName}" with Cross Sale Group: "${crossSaleGroup}"`);

     // Extract data using the map, providing defaults
     var bonusAmountRaw = row[bonusHeaderMap.bonusAmount - 1];
     var actualBonusVal = bonusHeaderMap.actualBonusAmount ? row[bonusHeaderMap.actualBonusAmount - 1] : null; // Handle if actualBonusAmount wasn't found
     var busUnit = row[bonusHeaderMap.jobBusinessUnit - 1] || "";
     var dateVal = row[bonusHeaderMap.completionDate - 1] || "";
     var itemName = row[bonusHeaderMap.itemName - 1] || "";

     // Convert bonus to number (logic adapted from original)
     var bonusAmt = 0;
     if (typeof bonusAmountRaw === 'string' && bonusAmountRaw.includes('$')) {
       bonusAmt = parseFloat(bonusAmountRaw.replace(/[^0-9.-]+/g,''));
     } else if (bonusAmountRaw === true || bonusAmountRaw === 'true') {
       // Use actual bonus value if primary is 'true' or boolean true
       if (actualBonusVal !== null) {
         if (typeof actualBonusVal === 'string' && actualBonusVal.includes('$')) {
           bonusAmt = parseFloat(actualBonusVal.replace(/[^0-9.-]+/g,''));
         } else {
           bonusAmt = parseFloat(actualBonusVal || 0);
         }
       } else {
         console.log("Warning: Bonus amount was 'true' but no 'Actual Bonus Amount' column found or mapped for row " + (r + dataStartRow));
         bonusAmt = 0; // Set to 0 if 'true' but no backup column value
       }
     } else {
       bonusAmt = parseFloat(bonusAmountRaw || 0);
     }

     // If a valid bonus amount was calculated, add to totals and data
     if (!isNaN(bonusAmt) && bonusAmt > 0) {
       totalSpiffAmount += bonusAmt;
       customerData.push({
         customerName: custName,
         jobBusinessUnit: busUnit,
         completionDate: dateVal,
         commission: bonusAmt,
         itemName: itemName
       });

       // Check if it's a Yard Spiff
       if (crossSaleGroup && typeof crossSaleGroup === 'string' && crossSaleGroup.toUpperCase().includes("YARD")) {
         console.log(`Found YARD in Cross Sale Group: "${crossSaleGroup}" for customer: ${custName}`);
         
         // Extract the numeric value from the YARD string (e.g., "YARD25" should give 25)
         var yardMatch = crossSaleGroup.toUpperCase().match(/YARD(\d+)/);
         console.log(`Regex match result for "${crossSaleGroup}": ${yardMatch ? JSON.stringify(yardMatch[0] + " -> " + yardMatch[1]) : "no match"}`);
         
         if (yardMatch && yardMatch[1]) {
           // If we found a number after "YARD", use that as the yard amount
           var yardAmount = parseFloat(yardMatch[1]);
           console.log(`Extracted yard amount: ${yardAmount} from "${crossSaleGroup}"`);
           
           if (!isNaN(yardAmount)) {
             totalYardSpiffAmount += yardAmount;
             console.log(`Added ${yardAmount} to yard total, new total: ${totalYardSpiffAmount}`);
           } else {
             // Fallback to the full bonus amount if we couldn't parse a number
             totalYardSpiffAmount += bonusAmt;
             console.log(`Failed to parse yard amount, using full bonus amount: ${bonusAmt}`);
           }
         } else {
           // If there's no number after "YARD", use the full bonus amount
           totalYardSpiffAmount += bonusAmt;
           console.log(`No number found after YARD, using full bonus amount: ${bonusAmt}`);
         }
       }
     }
   }

   // 3) Get Technician sheet
   var techSheet = ss.getSheetByName(technicianName);
   if (!techSheet) {
     ui.alert('No sheet found for technician: ' + technicianName);
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }

   // 4) Update top summary spiffs in the tech sheet
   updateTopSummarySpiffs(techSheet, totalSpiffAmount, totalYardSpiffAmount);

   // 5) Find relevant sections in the tech sheet
   var spiffSectionRow = findSpiffCustomerDataSection(techSheet);
   if (spiffSectionRow <= 0) {
     ui.alert("Error: Could not find Spiff data section header in " + technicianName + "'s sheet.");
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }
   var spiffHeaderRow = spiffSectionRow + 1; // Row containing column titles like "Customer Name", "Amount" etc.
   var spiffDataStartRow = spiffHeaderRow + 1; // First row where actual spiff data goes

   // Find the start of the next major section (e.g., "Install") to determine available space
   var nextSectionRow = findNextSectionStart(techSheet, spiffDataStartRow); // Helper to find the next non-empty row in Col A
   if (nextSectionRow <= 0) {
     ui.alert("Error: Could not determine the end of the Spiff section in " + technicianName + "'s sheet. Could not find next section header.");
     resetActionDropdown(ratesSheet, actionRow, actionColumn);
     return;
   }
   console.log(`Spiff Header at ${spiffHeaderRow}, Data starts ${spiffDataStartRow}, Next Section at ${nextSectionRow}`);


   // 6) Clear existing Spiff data and formatting
   clearSpiffDataSection(techSheet);
   // After clearing, the nextSectionRow might have changed due to row deletion within clearSpiffDataSection.
   // Recalculate the available rows based on the single 'Total' row left by the clear function.
   // The 'Total' row is at spiffDataStartRow after clearing.
   var currentDataRows = 1; // Starts with just the 'Total' row.

   // 7) Manage rows in the spiff data section (adjust based on the cleared state)
   // Rows needed: customer entries + 1 for the total row
   var rowsNeeded = customerData.length + 1;
   console.log(`After clear: Current rows available (just Total row): ${currentDataRows}, Rows needed (data + Total): ${rowsNeeded}`);

   manageSheetRows(techSheet, spiffDataStartRow, currentDataRows, rowsNeeded);

   // 8) Write Spiff Data to Tech Sheet (Starts at spiffDataStartRow)
   writeSpiffDataToSheet(techSheet, spiffHeaderRow, customerData);

   // 9) Add/Update Total Row (This will overwrite the placeholder total row if data exists)
   addSpiffTotalRow(techSheet, spiffHeaderRow, customerData.length);

   // 10) Mark as done in 'Main' sheet
   if (ratesSheet && actionRow && actionColumn) {
      ratesSheet.getRange(actionRow, actionColumn).setValue("Complete");
   }

   ui.alert(
     'SPIFF bonus updated for ' + technicianName + '.\n' +
     'Total SPIFF: $' + totalSpiffAmount.toFixed(2) + ' (' + customerData.length + ' entries)\n' +
     'Yard Sign Spiff: $' + totalYardSpiffAmount.toFixed(2)
   );

 } catch(err) {
   console.error("Error in updateSpiffBonusWithCustomersList for " + technicianName + ": " + err.message + "\nStack: " + err.stack);
   ui.alert('Error processing Spiff/Bonus for ' + technicianName + ': ' + err.message);
   // Attempt to reset dropdown on error
   if (ratesSheet && actionRow && actionColumn) {
     try {
       resetActionDropdown(ratesSheet, actionRow, actionColumn);
     } catch (resetErr) {
       console.error("Failed to reset action dropdown: " + resetErr.message);
     }
   }
 }
}

/**
* Processes Spiff/Bonus for all technicians
* Ignores action column status completely
* No approval required
*/
function processAllSpiffBonusWithCustomers() {
 var ui = SpreadsheetApp.getUi();
 var ss = SpreadsheetApp.getActiveSpreadsheet();
 var ratesSheet = ss.getSheetByName(Modules.Constants.SHEET.MAIN);
 if (!ratesSheet) {
   ui.alert(Modules.Constants.SHEET.MAIN + ' sheet not found!');
   return;
 }

 var ratesMapping = Modules.Utilities.getRatesSheetMapping(); // Use utility function from core
 var ratesData = ratesSheet.getDataRange().getValues();
 var techsToProcess = [];

 // Get all sheets in the spreadsheet to check for existence
 var allSheets = ss.getSheets();
 var sheetNames = allSheets.map(function(sheet) {
   return sheet.getName();
 });

 // Gather all technicians who are eligible for Bonus processing
 for (var i = ratesMapping.dataStartRow - 1; i < ratesData.length; i++) { // Adjust index for 0-based array
   var row = ratesData[i];
   var techName = row[ratesMapping.nameColumn - 1];
   var position = row[ratesMapping.positionColumn - 1];
   
   // Convert position to string and normalize for comparison
   var positionStr = position ? position.toString().trim().toUpperCase() : "";

   // Ensure techName is valid, sheet exists, eligible for Bonus (not C1)
   if (techName && typeof techName === 'string' && techName.trim() !== "" && 
       sheetNames.indexOf(techName) !== -1 && 
       positionStr !== "C1" && positionStr !== "CLASS 1") {
     
     // Use @core utility function to check eligibility - fall back to simple position check if not available
     var isBonusEligible = true; // Default to eligible
     
     // Check if Utilities module has a technician eligibility function
     if (typeof Modules !== 'undefined' && 
         typeof Modules.Utilities !== 'undefined' && 
         typeof Modules.Utilities.isTechnicianEligibleForBonus === 'function') {
       isBonusEligible = Modules.Utilities.isTechnicianEligibleForBonus(techName, ratesSheet);
     }
     
     if (isBonusEligible) {
       techsToProcess.push({
         name: techName,
         row: i + 1, // 1-based row index
         col: ratesMapping.actionColumn
       });
     }
   }
 }

 if (techsToProcess.length === 0) {
   ui.alert('No eligible technicians found for Bonus processing.');
   return;
 }

 // Process each technician - no approval needed
 var errors = [];
 var successCount = 0;
 var processedTechs = [];
 var totalAmount = 0;
 
 for (var t = 0; t < techsToProcess.length; t++) {
   var tech = techsToProcess[t];
   try {
     console.log("Processing Bonus for: " + tech.name + " (Row: " + tech.row + ")");
     var result = updateSpiffBonusWithCustomersListAll(tech.name);
     successCount++;
     
     // Store details for this technician
     if (result && result.amount > 0) {
       processedTechs.push({
         name: tech.name,
         count: result.count || 0,
         amount: result.amount || 0
       });
       totalAmount += result.amount;
     }
   } catch (error) {
     console.error("Failed processing Bonus for " + tech.name + ": " + error.message);
     errors.push(tech.name + ": " + error.message);
   }
 }

 // Build pretty summary message like the screenshot
 var summaryMessage = [];
 summaryMessage.push("BONUS PROCESSING COMPLETE");
 
 // Add summary section
 summaryMessage.push("\nSUMMARY:");
 summaryMessage.push("• Total Technicians Processed: " + successCount);
 summaryMessage.push("• Total Amount: $" + totalAmount.toFixed(2));
 
 // Add technician details section
 if (processedTechs.length > 0) {
   summaryMessage.push("\nDETAILS BY TECHNICIAN:");
   
   for (var i = 0; i < processedTechs.length; i++) {
     var techInfo = processedTechs[i];
     summaryMessage.push("\n" + techInfo.name + ":");
     summaryMessage.push("• Entries: " + techInfo.count);
     summaryMessage.push("• Amount: $" + techInfo.amount.toFixed(2));
   }
 }
 
 // Add errors section if we have any
 if (errors.length > 0) {
   summaryMessage.push("\nERRORS:");
   for (var j = 0; j < errors.length; j++) {
     summaryMessage.push("• " + errors[j]);
   }
 }
 
 // Show the popup
 ui.alert(summaryMessage.join("\n"));
}

/**
* Modified version of updateSpiffBonusWithCustomersList that returns results
* @param {string} technicianName - The technician's name
* @return {object} Result object with count and amount
*/
function updateSpiffBonusWithCustomersListAll(technicianName) {
  try {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var techSheet = ss.getSheetByName(technicianName);
    
    if (!techSheet) {
      throw new Error("Technician sheet not found");
    }
    
    var spiffBonusSheet = ss.getSheetByName('Spiff/Bonus');
    if (!spiffBonusSheet) {
      throw new Error("Spiff/Bonus sheet not found");
    }
    
    // Process the spiff/bonus data
    var result = processSpiffAndBonusData(techSheet, technicianName, spiffBonusSheet);
    
    return {
      count: result.entryCount || 0,
      amount: result.totalAmount || 0
    };
  } catch (error) {
    console.error("Error in updateSpiffBonusWithCustomersListAll: " + error.message);
    throw error;
  }
}

/**
* Adds or updates the total row at the end of spiff data section.
* @param {Sheet} sheet - The technician's sheet.
* @param {number} headerRow - The row containing the column headers for the spiff section.
* @param {number} dataCount - The number of spiff data entries (not counting the total row).
*/
function addSpiffTotalRow(sheet, headerRow, dataCount) {
  if (!sheet || !headerRow) {
    console.error("addSpiffTotalRow: Missing required parameters");
    return;
  }
  
  try {
    // Get the headers to find the correct columns
    var headerRange = sheet.getRange(headerRow, 1, 1, 10); // Get up to 10 columns
    var headers = headerRange.getValues()[0];
    
    // Find column indices for Customer Name, Amount, and Type
    var customerCol = -1;
    var amountCol = -1;
    var typeCol = -1;
    
    for (var i = 0; i < headers.length; i++) {
      var header = headers[i].toString().toLowerCase();
      if (header.includes("customer")) {
        customerCol = i + 1; // 1-based column index
      } else if (header.includes("amount") || header.includes("commission")) {
        amountCol = i + 1;
      } else if (header.includes("type")) {
        typeCol = i + 1;
      }
    }
    
    // Verify we found the necessary columns
    if (customerCol === -1 || amountCol === -1) {
      console.error("addSpiffTotalRow: Could not find required columns");
      return;
    }
    
    // Calculate the row for the total based on header row and data count
    var totalRow = headerRow + dataCount + 1;
    
    // Set "Total" in the customer column
    sheet.getRange(totalRow, customerCol).setValue("Total");
    
    // Calculate sum of amount column
    if (dataCount > 0 && amountCol > 0) {
      var dataStartRow = headerRow + 1;
      var formula = "=SUM(" + 
                   sheet.getRange(dataStartRow, amountCol, dataCount, 1).getA1Notation() + 
                   ")";
      sheet.getRange(totalRow, amountCol).setFormula(formula);
    } else {
      // If no data, set total to 0
      sheet.getRange(totalRow, amountCol).setValue(0);
    }
    
    // Set "Total" in the type column if it exists
    if (typeCol > 0) {
      sheet.getRange(totalRow, typeCol).setValue("Total");
    }
    
    // Apply formatting
    var totalRange = sheet.getRange(totalRow, 1, 1, headers.length);
    totalRange.setFontWeight("bold");
    if (amountCol > 0) {
      sheet.getRange(totalRow, amountCol).setNumberFormat("$#,##0.00");
    }
    
    console.log("Added Spiff Total row at row " + totalRow);
  } catch (e) {
    console.error("Error in addSpiffTotalRow: " + e.message);
  }
}

/**
 * --- SHEET OPERATIONS FUNCTIONS ---
 */

/**
* Writes the calculated PBP data to the technician's sheet.
* @param {Sheet} techSheet - The specific technician's sheet object.
* @param {Array<object>} allPbpEntries - Array of calculated PBP entry objects.
* @param {number} totalTechnicianShare - The total calculated PBP share for the tech.
*/
Modules.PBP.writePbpDataToSheet = function(techSheet, allPbpEntries, totalTechnicianShare) {
  if (!techSheet || !allPbpEntries) {
    console.error("writePbpDataToSheet: Invalid arguments.");
    return;
  }

  // --- 1. Update Top Summary ---
  Modules.PBP.updateTopSummaryInstallPay(techSheet, totalTechnicianShare, allPbpEntries.length);

  // --- 2. Find existing PBP rows in column J ---
  var lastRow = techSheet.getLastRow();
  var existingPbpRows = findExistingPbpRows(techSheet);
  
  // --- 3. Prepare data for writing ---
  var tz = Session.getScriptTimeZone() || 'America/New_York';
  var dataToWrite = [];
  
  for (var idx = 0; idx < allPbpEntries.length; idx++) {
    var entry = allPbpEntries[idx];
    // Use internal fallback function instead of relying on Modules.Shared.DateUtils
    var dateObj = parseDateSafe(entry.completionDate);
    var displayDate = dateObj ? Utilities.formatDate(dateObj, tz, "MM/dd/yyyy") : (entry.completionDate || "");
    
    // Build notes column
    var notesParts = [];
    // Start with the tech's role and percentage for this job
    notesParts.push(`${entry.roleForJob} (${entry.splitPercentage.toFixed(1)}%)`);

    // Add the detailed team breakdown if available
    if (entry.teamDetails) {
      // Team details will be included regardless of whether it's a solo job or not
      notesParts.push(`Team: ${entry.teamDetails}`);
    }

    // Append the job's total PBP amount for full context
    var notesText = notesParts.join(' - ') + ` | Job PBP: $${entry.totalPbp.toFixed(2)}`;

    // --- New Column F content combining Business Unit & Item ---
    var colFText;
    if (entry.jobBusinessUnit && entry.itemName) {
      colFText = `${entry.jobBusinessUnit} / Item: ${entry.itemName}`;
    } else if (entry.jobBusinessUnit) {
      colFText = entry.jobBusinessUnit;
    } else if (entry.itemName) {
      colFText = `Item: ${entry.itemName}`;
    } else {
      colFText = "";
    }

    dataToWrite.push([
      entry.customerName || "",      // Column E: Customer Name
      colFText,                       // Column F: Combined info
      displayDate,                   // Column G: Completion Date
      entry.technicianShare,         // Column H: Commission Amount
      notesText,                     // Column I: Notes
      "PBP"                          // Column J: Type
    ]);
  }
  
  // --- 4. Write data to the sheet ---
  if (dataToWrite.length === 0) {
    console.log("No PBP data to write");
    return;
  }
  
  // If we have existing PBP rows, update them
  if (existingPbpRows.length > 0) {
    console.log("Found " + existingPbpRows.length + " existing PBP rows to update");
    
    // The number of rows we need to update
    var rowsToUpdate = Math.min(existingPbpRows.length, dataToWrite.length);
    
    // Update existing rows first
    for (var i = 0; i < rowsToUpdate; i++) {
      var targetRow = existingPbpRows[i];
      var targetRange = techSheet.getRange(targetRow, 5, 1, 6); // Columns E-J (5-10)
      targetRange.setValues([dataToWrite[i]]);
    }
    
    // If we have more entries than existing PBP rows, look for empty rows
    if (dataToWrite.length > existingPbpRows.length) {
      var remainingEntries = dataToWrite.slice(existingPbpRows.length);
      writeRemainingPbpEntries(techSheet, remainingEntries);
    }
    
    // If we have fewer entries than existing PBP rows, clear the excess rows
    if (existingPbpRows.length > dataToWrite.length) {
      console.log("Clearing " + (existingPbpRows.length - dataToWrite.length) + " excess PBP rows");
      for (var j = dataToWrite.length; j < existingPbpRows.length; j++) {
        var excessRow = existingPbpRows[j];
        // Only delete data in columns E-J (5-10) where column J contains "PBP"
        // These rows come from findExistingPbpRows, which guarantees column J contains "PBP"
        techSheet.getRange(excessRow, 5, 1, 6).clearContent();
      }
    }
  } else {
    // No existing PBP rows, write all entries to empty rows
    writeRemainingPbpEntries(techSheet, dataToWrite);
  }
  
  console.log("Sheet update finished for: " + techSheet.getName());
};

/**
 * Finds all rows that have "PBP" in column J
 * @param {Sheet} sheet - The technician sheet to search
 * @return {Array} Array of row numbers that have "PBP" in column J
 */
function findExistingPbpRows(sheet) {
  var lastRow = sheet.getLastRow();
  var typeColumn = 10; // Column J
  var rows = [];
  
  // Skip if sheet doesn't have enough columns
  if (sheet.getLastColumn() < typeColumn) {
    return rows;
  }
  
  // Get all values in column J
  var typeValues = sheet.getRange(1, typeColumn, lastRow, 1).getValues();
  
  // Find rows with "PBP" in column J - ONLY these rows will ever be cleared
  for (var i = 0; i < typeValues.length; i++) {
    var cellValue = typeValues[i][0];
    if (cellValue && typeof cellValue === 'string' && 
        cellValue.toString().trim().toLowerCase() === "pbp") {
      rows.push(i + 1); // Convert to 1-based row index
    }
  }
  
  console.log("Found " + rows.length + " rows with PBP in type column");
  return rows;
}

/**
 * Writes PBP entries to empty rows in columns E-J
 * @param {Sheet} sheet - The technician sheet
 * @param {Array} entries - The PBP entries to write
 */
function writeRemainingPbpEntries(sheet, entries) {
  if (!entries || entries.length === 0) return;
  
  // Find the header row with "Customer Name" in column E
  var headerRow = findCustomerNameHeaderRow(sheet);
  if (headerRow <= 0) {
    console.log("Could not find 'Customer Name' header in column E in " + sheet.getName());
    return;
  }
  
  // Start looking at the row after the header
  var firstDataRow = headerRow + 1;
  var lastRow = sheet.getLastRow();
  
  // Find first empty row in columns E-J
  var startRow = -1;
  var rowsToSearch = Math.min(50, lastRow - firstDataRow + 1); // Cap at 50 rows
  
  if (rowsToSearch > 0) {
    var rowData = sheet.getRange(firstDataRow, 5, rowsToSearch, 6).getValues(); // Columns E-J (5-10)
    
    for (var i = 0; i < rowData.length; i++) {
      var isEmpty = true;
      for (var j = 0; j < rowData[i].length; j++) {
        if (rowData[i][j] !== "") {
          isEmpty = false;
          break;
        }
      }
      
      if (isEmpty) {
        startRow = firstDataRow + i;
        break;
      }
    }
  }
  
  // If we couldn't find an empty row, use the first data row
  if (startRow === -1) {
    startRow = firstDataRow;
    console.log("No empty rows found, using first row after header: " + startRow);
  }
  
  console.log("Writing " + entries.length + " entries starting at row " + startRow);
  
  // Write each entry
  for (var k = 0; k < entries.length; k++) {
    var currentRow = startRow + k;
    var targetRange = sheet.getRange(currentRow, 5, 1, 6); // Columns E-J (5-10)
    targetRange.setValues([entries[k]]);
    
    // Apply formatting
    sheet.getRange(currentRow, 7, 1, 1).setNumberFormat('MM/dd/yyyy'); // Date column format
    sheet.getRange(currentRow, 8, 1, 1).setNumberFormat('$#,##0.00'); // Commission column format
  }
}

/**
 * Finds the row that contains "Customer Name" in column E
 * @param {Sheet} sheet - The technician sheet
 * @return {number} The row number (1-based) or -1 if not found
 */
function findCustomerNameHeaderRow(sheet) {
  var lastRow = Math.min(50, sheet.getLastRow()); // Check first 50 rows
  var columnE = sheet.getRange(1, 5, lastRow, 1).getValues();
  
  for (var i = 0; i < columnE.length; i++) {
    var cellValue = columnE[i][0];
    if (cellValue && typeof cellValue === 'string' &&
        cellValue.toString().trim().toLowerCase() === "customer name") {
      return i + 1; // Convert to 1-based row index
    }
  }
  
  return -1; // Not found
}

/**
* Updates the top summary section ('Total Install Pay') with amount and count.
* @param {Sheet} sheet - The technician sheet to update.
* @param {number} amount - The total PBP amount.
* @param {number} count - The number of PBP entries.
*/
Modules.PBP.updateTopSummaryInstallPay = function(sheet, amount, count) {
  if (!sheet) return;
  // Target row 13 specifically for Total Install Pay based on screenshot
  var installPayRow = 13;
  try {
     sheet.getRange(installPayRow, 2).setValue(count); // Count in Col B (B13)
     sheet.getRange(installPayRow, 3).setValue(amount).setNumberFormat("$#,##0.00"); // Amount in Col C (C13)
     console.log("Updated Total Install Pay in B13/C13 with count: " + count + ", amount: $" + amount.toFixed(2));
  } catch (e) { 
     console.error("Error updating top summary install pay for " + sheet.getName() + ": " + e); 
     
     // Fallback to searching for "Total Install Pay" if row 13 doesn't work
     var data = sheet.getRange("A1:A20").getValues(); // Check first 20 rows
     for (var row = 0; row < data.length; row++) {
       if (data[row][0] && data[row][0].toString().trim() === "Total Install Pay") {
         installPayRow = row + 1;
         try {
           sheet.getRange(installPayRow, 2).setValue(count); // Count in Col B
           sheet.getRange(installPayRow, 3).setValue(amount).setNumberFormat("$#,##0.00"); // Amount in Col C
           console.log("Fallback: Updated Total Install Pay in row " + installPayRow);
         } catch (err) { 
           console.error("Fallback also failed to update top summary: " + err); 
         }
         break;
       }
     }
  }
};

/**
* Finds the row where the Install Customer Data section starts.
* @param {Sheet} sheet - The sheet to search in.
* @return {number} The row number (1-based) or -1 if not found.
*/
function findInstallCustomerDataSection(sheet) {
  if (!sheet) return -1;
  var data = sheet.getRange("A1:A50").getValues(); // Search first 50 rows
  for (var i = 0; i < data.length; i++) {
    var value = data[i][0];
    if (value && typeof value === "string") {
      var trimmedValue = value.trim();
      if (trimmedValue === "Install [Customer Data]" || trimmedValue === "Install Customer Data" || trimmedValue === "Install & Sales") { return i + 1; }
    }
  }
  // Fallback search (case-insensitive, partial, below row 15)
  for (var i = 0; i < data.length; i++) { // Start from the beginning instead of row 15
     var value = data[i][0];
     if (value && typeof value === "string") {
       var lowerValue = value.toLowerCase().trim();
       if (lowerValue.includes("install") && (lowerValue.includes("customer") || lowerValue.includes("data") || lowerValue.includes("sales") || lowerValue.includes("&"))) {
         console.log("Found install section using partial match: '" + value + "' at row " + (i+1));
         return i + 1;
       }
     }
  }
  console.log("No Install section header found in sheet: " + sheet.getName());
  return -1;
}

/**
* Finds the row where the next section after Install starts.
* @param {Sheet} sheet - The sheet to search in.
* @param {number} installSectionRow - The row where the Install section starts.
* @return {number} The row number (1-based) or -1 if not found.
*/
function findNextSectionAfterInstall(sheet, installSectionRow) {
  if (!sheet || installSectionRow <= 0) return -1;
  var startSearchRow = installSectionRow + 3; // Start looking below header/first data
  var maxSearchRow = Math.min(sheet.getLastRow() + 1, installSectionRow + 60); // Search ample rows
  if (startSearchRow >= maxSearchRow) return -1;


  var searchValues = sheet.getRange(startSearchRow, 1, maxSearchRow - startSearchRow, 1).getValues();
  for (var i = 0; i < searchValues.length; i++) {
    var rowValue = searchValues[i][0];
    var actualRow = startSearchRow + i;
    if (rowValue && typeof rowValue === "string") {
      var trimmedValue = rowValue.trim();
      var lowerValue = trimmedValue.toLowerCase();
      // Look for non-empty cells that don't seem like data continuation or total rows
      if (trimmedValue.length > 0 && !lowerValue.includes("install") && !lowerValue.includes("total")) {
         // Simple check: If it contains common section words or ends with 'Data]'?
        if (lowerValue.includes("data") || lowerValue.includes("sales") || lowerValue.includes("spiff") || lowerValue.includes("bonus") || lowerValue.includes("lead") || lowerValue.includes("customer") || trimmedValue.endsWith("Data]")) {
           console.log("Found next section header '" + trimmedValue + "' at row " + actualRow);
           return actualRow;
        }
      }
    }
  }
  console.log("No next section found after Install section in sheet: " + sheet.getName());
  return -1;
}

/**
* Clears the data rows in the Install section where Type column (J) contains 'PBP'.
* Only clears columns E-J (5-10), preserving columns A-D.
*
* @param {Sheet} sheet - The technician sheet to clear.
* @return {number} The number of rows cleared
*/
Modules.PBP.clearInstallDataSection = function(sheet) {
  if (!sheet) return 0;
  try {
    // First, find the Install section
    var installSectionRow = findInstallCustomerDataSection(sheet);
    if (installSectionRow <= 0) {
      console.log("Clear Install Data: Install section not found in " + sheet.getName());
      return 0;
    }
    
    var dataStartRow = installSectionRow + 1;
    var nextSectionRow = findNextSectionAfterInstall(sheet, installSectionRow);
    
    if (nextSectionRow <= 0) {
      nextSectionRow = sheet.getLastRow() + 1;
      console.log("No next section found, using last row + 1 (" + nextSectionRow + ") as boundary");
    }

    var rowsAvailable = nextSectionRow - dataStartRow;
    if (rowsAvailable <= 0) {
      console.log("No data rows available to clear in " + sheet.getName());
      return 0;
    }
    
    // Find existing PBP rows
    var pbpRows = findExistingPbpRows(sheet);
    
    // ONLY clear the CELLS in columns E-J where Type column (J) contains 'PBP'
    var rowsCleared = 0;
    for (var i = 0; i < pbpRows.length; i++) {
      var rowToClear = pbpRows[i];
      // Only clear row if it's in the Install section range
      if (rowToClear >= dataStartRow && rowToClear < nextSectionRow) {
        sheet.getRange(rowToClear, 5, 1, 6).clearContent(); // Clear ONLY columns E-J (5-10)
        rowsCleared++;
      }
    }
    
    console.log("Cleared " + rowsCleared + " rows with Type='PBP' in " + sheet.getName());
    return rowsCleared;
  } catch (e) {
    console.error("Error clearing install data section: " + e.message);
    return 0;
  }
};

/**
 * Local fallback date parsing function in case Modules.Shared.DateUtils is not available
 * Attempts to convert a value to a Date object
 * 
 * @param {*} value - The value to parse as a date
 * @return {Date|null} A Date object or null if parsing fails
 */
function parseDateSafe(value) {
  if (value instanceof Date) return value;
  
  if (typeof value === 'number') {
    // Google Sheets often stores dates as serial numbers (days since Dec 30, 1899)
    return new Date(Math.round((value - 25569) * 86400000));
  }
  
  if (typeof value === 'string') {
    var parsed = new Date(value);
    if (!isNaN(parsed.getTime())) return parsed;
  }
  
  return null;
}

/**
 * Main entry point for processing all PBP for all technicians.
 * Called from the menu or other trigger points.
 * Delegates to the appropriate PBP processing functions.
 */
function pbpMain_processAllPBP() {
  console.log("PBP: processAll called");
  
  var ui = SpreadsheetApp.getUi();
  
  // Removed confirmation popup to avoid duplicate prompt
  
  try {
    // Check if we have a dedicated function for processing all PBP
    if (typeof Modules !== 'undefined' && 
        typeof Modules.PBP !== 'undefined' && 
        typeof Modules.PBP.processAllPBP === 'function') {
      
      // Use the dedicated module function if available
      Modules.PBP.processAllPBP();
    } else {
      // Fallback to a simpler implementation using existing functions
      var ss = SpreadsheetApp.getActiveSpreadsheet();
      var technicians = getAllEligibleTechnicians();
      
      if (technicians.length === 0) {
        ui.alert("No eligible technicians found for PBP processing.");
        return;
      }
      
      var successCount = 0;
      var errors = [];
      
      for (var i = 0; i < technicians.length; i++) {
        try {
          // If there's a specific function for processing a single technician's PBP, call it
          if (typeof Modules.PBP.processPBPForTechnician === 'function') {
            Modules.PBP.processPBPForTechnician(technicians[i]);
          } else {
            // Otherwise just clear and let the next run populate data
            var techSheet = ss.getSheetByName(technicians[i]);
            if (techSheet) {
              Modules.PBP.clearInstallDataSection(techSheet);
            }
          }
          successCount++;
        } catch (error) {
          console.error("Error processing PBP for " + technicians[i] + ": " + error.message);
          errors.push(technicians[i] + ": " + error.message);
        }
      }
      
      // Show summary
      var message = "PBP PROCESSING COMPLETE\n\nProcessed " + successCount + " technicians.";
      if (errors.length > 0) {
        message += "\n\nErrors:\n" + errors.join("\n");
      }
      ui.alert(message);
    }
  } catch (e) {
    console.error("Error in pbpMain_processAllPBP: " + e.message);
    ui.alert("Error processing PBP: " + e.message);
  }
}

/**
 * Helper function to get all eligible technicians for PBP processing.
 * @return {Array} Array of technician names who are eligible for PBP
 */
function getAllEligibleTechnicians() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sheets = ss.getSheets();
  var sheetNames = sheets.map(function(sheet) { return sheet.getName(); });
  
  // If available, use the core utility function
  if (typeof Modules !== 'undefined' && 
      typeof Modules.Utilities !== 'undefined' && 
      typeof Modules.Utilities.getTechnicianNames === 'function') {
    return Modules.Utilities.getTechnicianNames();
  }
  
  // Fallback: get Main sheet and find technicians
  var mainSheet = ss.getSheetByName(
    typeof Modules !== 'undefined' && 
    typeof Modules.Constants !== 'undefined' && 
    typeof Modules.Constants.SHEET !== 'undefined' ? 
    Modules.Constants.SHEET.MAIN : 'Main'
  );
  
  if (!mainSheet) return [];
  
  var techNames = [];
  var lastRow = mainSheet.getLastRow();
  var nameCol = 1; // Assume column A has technician names
  
  if (lastRow <= 1) return [];
  
  var nameValues = mainSheet.getRange(2, nameCol, lastRow-1, 1).getValues();
  for (var i = 0; i < nameValues.length; i++) {
    var name = nameValues[i][0];
    if (name && typeof name === 'string' && name.trim() !== "" && 
        sheetNames.indexOf(name) !== -1) {
      techNames.push(name);
    }
  }
  
  return techNames;
}

/**
 * Process PBP for a single technician
 * @param {string} technicianName - The name of the technician
 * @return {object} Result with count and amount properties
 */
Modules.PBP.processPBPForTechnician = function(technicianName) {
  try {
    console.log("Processing PBP for: " + technicianName);
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var techSheet = ss.getSheetByName(technicianName);
    
    if (!techSheet) {
      console.error("No sheet found for technician: " + technicianName);
      return { count: 0, amount: 0 };
    }
    
    // First clear existing PBP data
    var clearedRows = Modules.PBP.clearInstallDataSection(techSheet);
    console.log("Cleared " + clearedRows + " PBP rows for " + technicianName);
    
    // Now actually calculate and add data - this was missing!
    
    // 1. Get the necessary data
    var spiffBonusSheet = ss.getSheetByName('Spiff/Bonus');
    var ratesSheet = ss.getSheetByName(Modules.Constants && Modules.Constants.SHEET ? 
                                       Modules.Constants.SHEET.MAIN : 'Main');
    
    if (!spiffBonusSheet) {
      console.error("Spiff/Bonus sheet not found - cannot process PBP data");
      Modules.PBP.updateTopSummaryInstallPay(techSheet, 0, 0);
      return { count: 0, amount: 0 };
    }
    
    if (!ratesSheet) {
      console.error("Main sheet not found - cannot process PBP data");
      Modules.PBP.updateTopSummaryInstallPay(techSheet, 0, 0);
      return { count: 0, amount: 0 };
    }
    
    // 2. Get all data from the sheets (do this once)
    var spiffBonusData = spiffBonusSheet.getDataRange().getValues();
    var ratesData = ratesSheet.getDataRange().getValues();
    
    // 3. Calculate PBP entries
    console.log("Calculating PBP entries for: " + technicianName);
    var calculationResult = calculatePbpEntries(technicianName, spiffBonusData, ratesData);
    var allPbpEntries = calculationResult.entries;
    var totalTechnicianShare = calculationResult.totalShare;
    
    console.log("Found " + allPbpEntries.length + " PBP entries with total share: $" + totalTechnicianShare);
    
    // 4. Update the technician's sheet with the calculated data
    if (allPbpEntries.length > 0) {
      Modules.PBP.writePbpDataToSheet(techSheet, allPbpEntries, totalTechnicianShare);
      console.log("Successfully wrote PBP data to " + technicianName + "'s sheet");
    } else {
      // No entries found, just update the summary to 0
      Modules.PBP.updateTopSummaryInstallPay(techSheet, 0, 0);
      console.log("No PBP entries found for " + technicianName);
    }
    
    return {
      count: allPbpEntries.length,
      amount: totalTechnicianShare
    };
  } catch (error) {
    console.error("Error in processPBPForTechnician for " + technicianName + ": " + error.message + "\n" + error.stack);
    // Try to update the summary to 0 anyway
    try {
      if (techSheet) {
        Modules.PBP.updateTopSummaryInstallPay(techSheet, 0, 0);
      }
    } catch (e) {
      console.error("Failed to update summary: " + e.message);
    }
    return { count: 0, amount: 0 };
  }
};

/**
 * Local fallback implementation of TechnicianUtils.getTechnicianClassAndRole
 * Used when the shared module isn't available
 * 
 * @param {string} title - The technician's title/position
 * @return {object} Object with class, role, and isEligible properties
 */
function getClassAndRoleFromTitle(title) {
  if (!title) {
    return { class: 0, role: 'None', isEligible: false };
  }
  
  var titleLower = title.toString().toLowerCase().trim();
  
  // Explicit class detection from dropdown values in the screenshot
  if (titleLower === 'class 4' || titleLower === 'c4') {
    return { class: 4, role: 'Lead', isEligible: true };
  }
  
  if (titleLower === 'class 3' || titleLower === 'c3') {
    return { class: 3, role: 'Lead', isEligible: true };
  }
  
  if (titleLower === 'class 2' || titleLower === 'c2') {
    return { class: 2, role: 'Assistant', isEligible: true };
  }
  
  if (titleLower === 'class 1' || titleLower === 'c1') {
    return { class: 1, role: 'None', isEligible: false };
  }
  
  // Class 4 roles (highest seniority)
  if (titleLower.includes('master') || titleLower.includes('senior tech')) {
    return { class: 4, role: 'Lead', isEligible: true };
  }
  
  // Class 3 roles (mid-senior)
  if (titleLower.includes('journeyman') || titleLower.includes('tech 3') || titleLower.includes('technician 3')) {
    return { class: 3, role: 'Lead', isEligible: true };
  }
  
  // Class 2 roles (qualified techs)
  if (titleLower.includes('tech 2') || titleLower.includes('technician 2') || 
      titleLower.includes('c2') || titleLower.match(/class\s*2/)) {
    return { class: 2, role: 'Assistant', isEligible: true };
  }
  
  // Class 1 roles (apprentice or new techs) - not eligible for PBP/bonus
  if (titleLower.includes('tech 1') || titleLower.includes('technician 1') || 
      titleLower.includes('c1') || titleLower.match(/class\s*1/) || 
      titleLower.includes('apprentice')) {
    return { class: 1, role: 'None', isEligible: false };
  }
  
  // Default fallback
  return { class: 2, role: 'Assistant', isEligible: true };
}

/**
* Processes PBP entries from Spiff/Bonus data and calculates shares based on class/role logic.
* 
* @param {string} technicianName - The name of the technician being processed.
* @param {Array<Array>} spiffBonusData - 2D array of data from 'Spiff/Bonus' sheet.
* @param {Array<Array>} ratesData - 2D array of data from Modules.Constants.SHEET.MAIN sheet.
* @return {object} An object containing { entries: Array<object>, totalShare: number }.
*/
function calculatePbpEntries(technicianName, spiffBonusData, ratesData) {
  // Ensure TechnicianUtils is available or use fallback
  var getTechClassAndRole = (Modules.Shared && 
                           Modules.Shared.TechnicianUtils && 
                           Modules.Shared.TechnicianUtils.getTechnicianClassAndRole) ? 
    Modules.Shared.TechnicianUtils.getTechnicianClassAndRole : 
    getClassAndRoleFromTitle;
  
  // Build a cache of technician details for quick lookups
  var techCache = {};
  // Build technician details cache with fallback
  for (var r = 1; r < ratesData.length; r++) {
    var row = ratesData[r];
    if (!row[0]) continue;
    var name = row[0].toString().trim();
    var lower = name.toLowerCase();
    if (techCache[lower]) continue;
    var title = row[2] ? row[2].toString() : '';
    var info = getTechClassAndRole(title);
    techCache[lower] = {
      name: name,
      class: info.class,
      isEligible: info.isEligible,
      initialRole: info.role
    };
  }
  
  var processed = {};  // Track processed entries to avoid duplicates
  var resultEntries = [];
  var totalShare = 0;

  // Helper to parse names with fallback
  function parseTechnicianNames(str) {
    if (!str) return [];
    
    // Use Shared utility if available
    if (Modules.Shared && 
        Modules.Shared.TechnicianUtils && 
        Modules.Shared.TechnicianUtils.parseTechnicianNames) {
      return Modules.Shared.TechnicianUtils.parseTechnicianNames(str);
    }
    
    // Fallback implementation
    return String(str)
      .split(/[,\n&]+/)
      .map(function(s) { return s.trim(); })
      .filter(function(s) { return s.length > 0; });
  }

  // Process each row in the Spiff/Bonus sheet (skip header row)
  for (var r = 1; r < spiffBonusData.length; r++) {
    var row = spiffBonusData[r];
    
    // Check the Cross-Sale Group column for PBP information 
    var crossSaleValue = row[9] || ""; // Typically column J
    if (!crossSaleValue) continue;
    
    // Check for PBP marker
    var pbpMatch = String(crossSaleValue).match(/pbp\s*(\d+(?:\.\d+)?)/i);
    var pbpAmount = pbpMatch && pbpMatch[1] ? parseFloat(pbpMatch[1]) : 0;
    if (!pbpAmount) continue; // Skip if no PBP amount found
    
    // Get technician names from the sheet
    var primaryTechCol = 6; // Column G - Primary Technician
    var assignedTechsCol = 7; // Column H - Assigned Technicians
    
    // Get unique technician names for this job
    var uniqueNames = [];
    var lowerSet = new Set();

    // Helper to add names uniquely
    function addTech(name) {
      if (!name) return;
      var trimmed = String(name).trim();
      var lower = trimmed.toLowerCase();
      if (trimmed && !lowerSet.has(lower)) {
        uniqueNames.push(trimmed);
        lowerSet.add(lower);
      }
    }

    // Add primary tech and all assigned techs
    addTech(row[primaryTechCol]);
    var assignedTechs = parseTechnicianNames(row[assignedTechsCol] || '');
    for (var a = 0; a < assignedTechs.length; a++) {
      addTech(assignedTechs[a]);
    }
    
    // Check if the current technician is involved in this job
    if (!lowerSet.has(technicianName.toLowerCase())) continue;
    
    // Create a key to deduplicate entries
    var customerName = row[1] || ""; // Column B
    var completionDate = row[3] || ""; // Column D
    var itemName = row[10] || ""; // Column K
    var key = [customerName, completionDate, itemName, pbpAmount].join('|');
    
    // Skip if we've already processed this entry
    if (processed[key]) continue;
    processed[key] = true;
    
    // Calculate split percentages - simplified fallback
    var techs = [];
    var highestClass = 0;
    var hasPaidTechs = false;

    // Populate base info and find highest class present
    for (var u = 0; u < uniqueNames.length; u++) {
      var techName = uniqueNames[u];
      var cached = techCache[techName.toLowerCase()];
      var techInfo = cached || { 
        name: techName, 
        class: 2, // Default to Class 2
        isEligible: true, 
        initialRole: 'Assistant' 
      };
      
      // Only count higher class if tech is eligible for payment
      if (techInfo.isEligible && techInfo.class > highestClass) {
        highestClass = techInfo.class;
      }
      
      // Track if we have any paid techs
      if (techInfo.isEligible && techInfo.class >= 2) {
        hasPaidTechs = true;
      }
      
      techs.push({
        name: techInfo.name,
        class: techInfo.class,
        isEligible: techInfo.isEligible,
        initialRole: techInfo.initialRole,
        finalRole: techInfo.initialRole,
        splitPercent: 0,
        payout: 0
      });
    }

    // Skip if no eligible techs
    if (!hasPaidTechs) continue;

    // Only count eligible techs (class 2+) in total count for splitting
    var eligibleTechs = techs.filter(function(t) { 
      return t.isEligible && t.class >= 2; 
    });
    var total = eligibleTechs.length;
    var hasHighClass = techs.some(function(t) { return t.class >= 3 && t.isEligible; });

    // Determine final role per rules - ONLY for eligible techs
    techs.forEach(function(t) {
      // Class 1 techs get Assistant role but remain ineligible for payment
      if (t.class === 1) {
        t.isEligible = false;
        t.finalRole = 'Assistant';
        return;
      }
      
      if (!t.isEligible) return; // Skip other ineligible techs
      
      if (t.class === 2 && t.class === highestClass && !hasHighClass) t.finalRole = 'Lead';
      if (total === 1 && t.class >= 2) t.finalRole = 'Lead';
    });

    // Count all roles for split calculations, including Class 1 as Assistants
    var leadCount = techs.filter(function(t){ 
      return t.finalRole === 'Lead'; 
    }).length;
    
    var assistantCount = techs.filter(function(t){ 
      return t.finalRole === 'Assistant'; 
    }).length;

    // Calculate split percentage for all techs, but only eligible techs get payouts
    techs.forEach(function(t) {
      // Use Shared.PayrollUtils.calculateSplitPercentage if available
      var splitPercent = 0;
      
      if (typeof Modules !== 'undefined' && 
          typeof Modules.Shared !== 'undefined' && 
          typeof Modules.Shared.PayrollUtils !== 'undefined' && 
          typeof Modules.Shared.PayrollUtils.calculateSplitPercentage === 'function') {
        // Use the proper implementation that follows business rules
        splitPercent = Modules.Shared.PayrollUtils.calculateSplitPercentage(
          total, leadCount, assistantCount, t.finalRole);
      } else {
        // Fallback calculation only if shared function unavailable
        var effectiveTotal = leadCount + assistantCount;
        
        // Solo tech gets full amount
        if (effectiveTotal === 1) {
          splitPercent = 100;
        } 
        // Two techs - 65/35 split for Lead/Assistant, 50/50 for same roles
        else if (effectiveTotal === 2) {
          if (leadCount === 1 && assistantCount === 1) {
            splitPercent = t.finalRole === 'Lead' ? 65 : 35;
          } else {
            splitPercent = 50; // 2 Leads OR 2 Assistants
          }
        } 
        // Three techs - use proper 3-tech splits per business rules
        else if (effectiveTotal === 3) {
          if (leadCount === 1 && assistantCount === 2) {
            splitPercent = t.finalRole === 'Lead' ? 46 : 27;
          } else if (leadCount === 2 && assistantCount === 1) {
            splitPercent = t.finalRole === 'Lead' ? 38 : 24;
          } else {
            splitPercent = 100 / 3; // Equal split for 3 leads or 3 assistants
          }
        }
        // Four techs - use proper 4-tech splits per business rules
        else if (effectiveTotal === 4) {
          if (leadCount === 2 && assistantCount === 2) {
            splitPercent = t.finalRole === 'Lead' ? 30 : 20;
          } else if (leadCount === 3 && assistantCount === 1) {
            splitPercent = t.finalRole === 'Lead' ? 30 : 10;
          } else {
            splitPercent = 25; // Equal split for 4 leads or 4 assistants
          }
        }
        // More than 4 techs - equal split (fallback)
        else if (effectiveTotal > 4) {
          // Fall back to equal split for 5+ techs
          splitPercent = 100 / effectiveTotal;
        }
      }
      
      t.splitPercent = splitPercent;
      
      // But only eligible techs get paid
      t.payout = (t.isEligible && t.finalRole !== 'None') ? pbpAmount * (splitPercent / 100) : 0;
    });
    
    // Find this technician's details
    var targetTech = null;
    for (var f = 0; f < techs.length; f++) {
      if (techs[f].name.toLowerCase() === technicianName.toLowerCase()) {
        targetTech = techs[f];
        break;
      }
    }
    
    // Skip if technician not found, not eligible, or no payout
    if (!targetTech || !targetTech.isEligible || targetTech.payout <= 0) continue;
    
    // Add entry to results
    resultEntries.push({
      customerName: customerName,
      jobBusinessUnit: row[2] || "", // Column C
      completionDate: completionDate,
      itemName: itemName,
      totalPbp: pbpAmount,
      technicianShare: targetTech.payout,
      roleForJob: targetTech.finalRole,
      splitPercentage: targetTech.splitPercent,
      isEligible: targetTech.isEligible,
      teamDetails: techs.map(function(t) {
        return t.name + " (C" + t.class + "/" + 
          // Show Class 1 as "Assistant" rather than "Not eligible" in the display string
          (t.class === 1 ? "Assistant" : (t.isEligible ? t.finalRole : "Not eligible")) + "/" + 
          t.splitPercent.toFixed(1) + "%)";
      }).join(', ')
    });
    
    // Add to total share
    totalShare += targetTech.payout;
  }

  return { 
    entries: resultEntries, 
    totalShare: totalShare 
  };
} 