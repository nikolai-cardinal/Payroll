/**
 * Payroll System - Bonus Utilities
 * Contains utility functions for the Bonus module.
 */

// Setup namespace
var Modules = Modules || {};
Modules.Bonus = Modules.Bonus || {};
Modules.Bonus.Utilities = Modules.Bonus.Utilities || {};

/**
 * Returns a standard mapping object for columns in the "Main" sheet.
 * @return {Object} An object with keys for common fields and their 1-based column indices.
 */
Modules.Bonus.Utilities.getRatesSheetMapping = function() {
  return {
    nameColumn: 1,       // Column A: Technician Name
    positionColumn: 3,   // Column C: Position
    actionColumn: 7,     // Column G: Action Dropdown
    dataStartRow: 3      // Row number where the actual technician data begins
  };
};

/**
 * Gets a mapping of column headers to column indices for the Spiff/Bonus sheet.
 * @param {Sheet} sheet - The Spiff/Bonus sheet.
 * @return {Object} Map of column names to indices.
 */
Modules.Bonus.Utilities.getBonusHeaderMap = function(sheet) {
  if (!sheet) return null;
  
  try {
    // Get the header row
    var headerRow = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    var headerMap = {};
    
    // Map column names to indices (1-indexed)
    for (var i = 0; i < headerRow.length; i++) {
      var header = headerRow[i]?.toString().trim().toLowerCase() || "";
      
      // Map standard header names and common variations
      if (header.includes("customer") || header === "cust name" || header === "customer name") {
        headerMap.customerName = i + 1;
      }
      else if (header.includes("business unit") || header === "bu") {
        headerMap.jobBusinessUnit = i + 1;
      }
      else if (header.includes("completion") || header === "date" || header === "completed") {
        headerMap.completionDate = i + 1;
      }
      else if (header.includes("sold by") || header === "sales rep") {
        headerMap.soldBy = i + 1;
      }
      else if (header.includes("assigned") || header === "tech" || header === "technician") {
        headerMap.assignedTechnician = i + 1;
      }
      else if (header.includes("bonus") || header.includes("spiff") || header.includes("commis")) {
        headerMap.bonusAmount = i + 1;
      }
      else if (header.includes("item") || header.includes("description") || header.includes("notes")) {
        headerMap.itemName = i + 1;
      }
    }
    
    return headerMap;
  } catch (e) {
    console.error("Error getting header map: " + e.message);
    return null;
  }
};

/**
 * Checks if a technician is Class 1 by examining the position column in the Main sheet.
 * @param {string} technicianName - The name of the technician to check.
 * @param {Sheet} ratesSheet - The Main sheet.
 * @return {boolean} True if the technician is Class 1, false otherwise.
 */
Modules.Bonus.Utilities.isTechnicianClass1 = function(technicianName, ratesSheet) {
  if (!technicianName || !ratesSheet) return false;
  
  try {
    // Get mapping to find technician row
    var ratesMapping = Modules.Bonus.Utilities.getRatesSheetMapping();
    
    // Find the technician row
    var techRow = Modules.Bonus.Utilities.findRowWithText(ratesSheet, technicianName, ratesMapping.nameColumn, ratesMapping.dataStartRow);
    if (techRow <= 0) {
      console.warn(`isTechnicianClass1: Could not find row for technician ${technicianName}`);
      return false;
    }
    
    // Get the value in position column
    var positionValue = ratesSheet.getRange(techRow, ratesMapping.positionColumn).getValue();
    
    // Check if it contains "Class 1" (case insensitive)
    if (positionValue && typeof positionValue === 'string' && 
        positionValue.toString().toLowerCase().includes('class 1')) {
      console.log(`Technician ${technicianName} is Class 1 - will skip Bonus processing`);
      return true;
    }
    
    return false;
  } catch (e) {
    console.error(`Error in isTechnicianClass1 for ${technicianName}: ${e.message}`);
    return false; // Default to not Class 1 in case of error
  }
};

/**
 * Finds a row containing the specified text.
 * @param {Sheet} sheet - The sheet to search in.
 * @param {string} textToFind - The text to find.
 * @param {number} column - The 1-based column index to search in.
 * @param {number} startRow - The 1-based row index to start searching from.
 * @param {number} endRow - Optional end row for the search (defaults to last row).
 * @param {boolean} allowPartialMatch - Whether to allow partial matches.
 * @return {number} The 1-based row index where the text was found, or -1 if not found.
 */
Modules.Bonus.Utilities.findRowWithText = function(sheet, textToFind, column, startRow, endRow, allowPartialMatch) {
  if (!sheet || !textToFind || !column || column < 1) {
    console.error("findRowWithText: Invalid parameters");
    return -1;
  }
  
  var begin = startRow || 1;
  var maxRow = endRow || sheet.getLastRow();
  var isPartialMatch = allowPartialMatch || false;
  
  if (begin > maxRow) {
    console.log(`findRowWithText: Start row (${begin}) is after end row (${maxRow})`);
    return -1;
  }
  
  // Optimize by getting values in a batch
  var numRowsToSearch = maxRow - begin + 1;
  if (numRowsToSearch <= 0) return -1;
  
  try {
    var range = sheet.getRange(begin, column, numRowsToSearch, 1);
    var values = range.getValues();
    var searchTextLower = textToFind.toString().trim().toLowerCase();
    
    for (var i = 0; i < values.length; i++) {
      var cellValue = values[i][0];
      if (cellValue) {
        var cellLower = cellValue.toString().trim().toLowerCase();
        
        if ((isPartialMatch && cellLower.includes(searchTextLower)) || 
            (!isPartialMatch && cellLower === searchTextLower)) {
          return begin + i; // Return the 1-based row index
        }
      }
    }
  } catch (e) {
    console.error(`findRowWithText: Error getting range or values: ${e.message}`);
  }
  
  return -1; // Not found
};

/**
 * Finds the row index of the Bonus data section in a technician's sheet.
 * @param {Sheet} sheet - The technician's sheet.
 * @return {number} The 1-based row index of the section header, or -1 if not found.
 */
Modules.Bonus.Utilities.findBonusDataSection = function(sheet) {
  if (!sheet) return -1;
  
  const possibleHeaders = [
    "Bonus Section", 
    "Bonus Data", 
    "Bonuses", 
    "Spiffs", 
    "Spiff/Bonus", 
    "Spiff Data",
    "Commissions"
  ];
  
  // Try to find any of the possible headers in Column A
  for (let i = 0; i < possibleHeaders.length; i++) {
    const row = Modules.Bonus.Utilities.findRowWithText(
      sheet, possibleHeaders[i], 1, 1, null, true
    );
    if (row > 0) return row;
  }
  
  // Fallback to searching for common headers in other columns
  for (let i = 0; i < possibleHeaders.length; i++) {
    for (let col = 2; col <= 5; col++) {
      const row = Modules.Bonus.Utilities.findRowWithText(
        sheet, possibleHeaders[i], col, 1, null, true
      );
      if (row > 0) return row;
    }
  }
  
  return -1;
};

/**
 * Parses a date value into a formatted string.
 * @param {*} dateValue - The date to format (Date object, string, etc.)
 * @param {string} format - The format pattern to use.
 * @param {string} timezone - The timezone to use.
 * @return {string} The formatted date string.
 */
Modules.Bonus.Utilities.formatDate = function(dateValue, format, timezone) {
  if (!dateValue) return "";
  
  var dateObj = Modules.Bonus.Utilities.tryParseDate(dateValue);
  if (!dateObj) return dateValue.toString(); // Return original if parsing fails
  
  var fmt = format || 'MM/dd/yyyy';
  var tz = timezone || Session.getScriptTimeZone() || 'America/New_York';
  
  try {
    return Utilities.formatDate(dateObj, tz, fmt);
  } catch (e) {
    console.error("Error formatting date: " + e.message);
    return dateValue.toString(); // Fallback to string representation
  }
};

/**
 * Attempts to parse a value into a valid Date object.
 * @param {*} input - The value to parse.
 * @return {Date|null} A valid Date object if parsing succeeds, otherwise null.
 */
Modules.Bonus.Utilities.tryParseDate = function(input) {
  if (!input) return null;
  
  // If it's already a valid Date object
  if (input instanceof Date && !isNaN(input.getTime())) {
    return input;
  }
  
  try {
    // Try direct parsing
    var d = new Date(input);
    if (!isNaN(d.getTime())) return d;
    
    // Try common spreadsheet format (e.g., M/D/YYYY)
    if (typeof input === 'string') {
      var parts = input.split(/[/\-]/);
      if (parts.length === 3) {
        var year = parseInt(parts[2], 10);
        var month = parseInt(parts[0], 10);
        var day = parseInt(parts[1], 10);
        
        if (year > 1000 && year < 3000 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
          d = new Date(year, month - 1, day);
          if (!isNaN(d.getTime()) && d.getFullYear() === year && (d.getMonth() + 1) === month && d.getDate() === day) {
            return d;
          }
        }
      }
    }
  } catch(e) {
    console.log(`tryParseDate: Error parsing input '${input}': ${e.message}`);
  }
  
  return null;
};

/**
 * Clears the Bonus data section in a technician's sheet.
 * @param {Sheet} sheet - The technician's sheet.
 * @param {Array} newData - Optional array of new data entries.
 * @return {number} Number of rows cleared.
 */
Modules.Bonus.Utilities.clearBonusDataSection = function(sheet, newData) {
  if (!sheet) return 0;
  
  try {
    // Find the section header row
    var sectionHeaderRow = Modules.Bonus.Utilities.findBonusDataSection(sheet);
    if (sectionHeaderRow <= 0) return 0;
    
    // Look for "Total" row after the data
    var totalRowOffset = 0;
    var searchLimit = Math.min(sectionHeaderRow + 50, sheet.getLastRow());
    for (var r = sectionHeaderRow + 1; r <= searchLimit; r++) {
      var value = sheet.getRange(r, 1).getValue();
      if (value && typeof value === 'string' && 
          value.toString().toLowerCase().includes('total')) {
        totalRowOffset = r - sectionHeaderRow;
        break;
      }
    }
    
    // If no total row found, find the start of the next section
    if (totalRowOffset === 0) {
      for (var r = sectionHeaderRow + 1; r <= searchLimit; r++) {
        // Check for the next section header (bold text in column A)
        var range = sheet.getRange(r, 1);
        var value = range.getValue();
        if (value && typeof value === 'string' && value.trim() !== "" && range.getFontWeight() === "bold") {
          totalRowOffset = r - sectionHeaderRow - 1;
          break;
        }
      }
    }
    
    // If we still don't have a section end, use a reasonable default
    if (totalRowOffset === 0) {
      totalRowOffset = Math.min(10, sheet.getLastRow() - sectionHeaderRow);
    }
    
    // Determine how many rows we need
    var rowsNeeded = (newData && newData.length > 0) ? newData.length + 2 : 2; // +2 for header and total
    
    // Clear the values in the existing section
    var rangeToClear = sheet.getRange(
      sectionHeaderRow + 1, 
      1, 
      totalRowOffset - 1, 
      10 // Clear 10 columns to be safe
    );
    
    rangeToClear.clearContent();
    
    // Return how many rows we cleared
    return totalRowOffset - 1;
  } catch (e) {
    console.error("Error clearing Bonus section: " + e.message);
    return 0;
  }
};

/**
 * Updates the top summary section in a technician's sheet with Bonus information.
 * @param {Sheet} techSheet - The technician's sheet.
 * @param {number} totalAmount - The total bonus amount.
 * @param {number} entryCount - The number of bonus entries.
 */
Modules.Bonus.Utilities.updateTopSummaryBonus = function(techSheet, totalAmount, entryCount) {
  if (!techSheet) return;
  
  try {
    // Find the "Spiff Pay" or "Bonus" cell in the top section (typically column A, rows 1-15)
    var summaryLabelRow = -1;
    var searchRange = techSheet.getRange(1, 1, 15, 1);
    var searchValues = searchRange.getValues();
    
    for (var i = 0; i < searchValues.length; i++) {
      var cellValue = searchValues[i][0];
      if (cellValue && typeof cellValue === 'string') {
        var lowerValue = cellValue.toString().toLowerCase();
        if (lowerValue.includes("spiff") || lowerValue.includes("bonus")) {
          summaryLabelRow = i + 1; // 1-based row index
          break;
        }
      }
    }
    
    if (summaryLabelRow <= 0) {
      console.log("Could not find Bonus summary row in top section");
      return;
    }
    
    // Update the amount cell (typically in column B)
    techSheet.getRange(summaryLabelRow, 2).setValue(totalAmount);
    
    console.log(`Updated top summary Bonus amount: $${totalAmount} (${entryCount} entries)`);
  } catch (e) {
    console.error("Error updating Bonus summary: " + e.message);
  }
};

/**
 * Writes Bonus data to a technician's sheet.
 * @param {Sheet} techSheet - The technician's sheet.
 * @param {number} headerRow - The row containing the section header.
 * @param {Array} customerData - Array of customer data entries.
 */
Modules.Bonus.Utilities.writeBonusDataToSheet = function(techSheet, headerRow, customerData) {
  if (!techSheet || headerRow <= 0 || !customerData) return;
  
  try {
    const dataStartRow = headerRow + 1;
    const dataCount = customerData.length;
    let totalAmount = 0;
    
    // Prepare the column headers in row headerRow+1 (if data exists)
    if (dataCount > 0) {
      techSheet.getRange(headerRow, 1, 1, 10).setFontWeight("bold");
      techSheet.getRange(headerRow + 1, 1, 1, 5).setValues([
        ["Customer", "Unit", "Date", "Amount", "Notes"]
      ]).setFontWeight("bold");
    }
    
    // Write data rows
    if (dataCount > 0) {
      const dataRange = techSheet.getRange(dataStartRow + 1, 1, dataCount, 5);
      const dataValues = customerData.map(item => {
        totalAmount += (item.commission || 0);
        return [
          item.customerName || "",
          item.jobBusinessUnit || "",
          item.completionDate || "",
          item.commission || 0,
          item.notes || ""
        ];
      });
      
      dataRange.setValues(dataValues);
      
      // Format the amount column as currency
      techSheet.getRange(dataStartRow + 1, 4, dataCount, 1).setNumberFormat("$#,##0.00");
      
      // Add a total row
      const totalRow = dataStartRow + 1 + dataCount;
      techSheet.getRange(totalRow, 1, 1, 5).setValues([
        ["TOTAL", "", "", totalAmount, ""]
      ]);
      techSheet.getRange(totalRow, 1).setFontWeight("bold");
      techSheet.getRange(totalRow, 4).setNumberFormat("$#,##0.00").setFontWeight("bold");
    }
    
    console.log(`Wrote ${dataCount} Bonus entries to technician sheet`);
  } catch (e) {
    console.error("Error writing Bonus data: " + e.message);
  }
}; 